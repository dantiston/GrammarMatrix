head-comp-phrase := basic-head-1st-comp-phrase & head-initial .

head-opt-comp-phrase := basic-head-opt-comp-phrase.

imp-head-opt-phrase := imp-head-opt-subj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM imp ].

adj-phrase := adj-head-int-phrase.

subj-head-phrase := decl-head-subj-phrase & head-final &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ] .

; Rules for bulding NPs.  Note that the Matrix uses SPR for
;                the specifier of nouns and SUBJ for the subject (specifier) of verbs.

; ERB 2007-05-14 I'm abusing the feature OPT to have [OPT +]
; now mean "obligatorily dropped".  To put this into effect,
; this rule must check for compatibility with [OPT -].

head-spec-phrase := basic-head-spec-phrase & head-final &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT - ] > ].

; Bare NP phrase.  Consider modifying the PRED value of the quantifier relation
;              introduced to match the semantic effect of bare NPs in your language.

; ERB 2007-05-11 To allow for the "indefinite" (i.e., bare nouns) to
; show up with demonstrative determiners yet still get the information
; [ COG-ST type-id ] otherwise, we need to have two bare-np phrases,
; as well as a feature DEF to track definiteness.  Similarly, need to
; allow definite detereminer to combine with these. 

; ERB 2007-05-11 Disallowing "weak" forms of adjectives from bare np.
; This will probably break if we add posthead PP modifiers which can
; attach after prehead adjectives.  Consider enforcing posthead attachment
; first in this language.

; ERB 2007-05-14 I had the facts wrong. MODIFIED doesn't seem to be 
; useful.  Rather, it should be enough for the def-bare-np-phrase
; to check for compatibility with [DEF +] and the indef-bare-np-phrase
; to insist on COG-ST type-id.  These two constraints should interact
; with the constraints on a) the definite and indefinite lexical rules
; and b) the adjectives to get the right set of facts.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS <! [ PRED "exist_q_rel" ] !> ].

indef-bare-np-phrase := bare-np-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST type-id ].

def-bare-np-phrase := bare-np-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF + ].


; comp-head-phrase can requires things that are [ HEAD adp ].

comp-head-phrase := basic-head-1st-comp-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD adp ] .

; Type for negative adverbs.

neg-adv-lex := basic-scopal-adverb-lex &
  [ SYNSEM.LOCAL.CAT [ VAL [ SPR < >,
                             COMPS < >,
                             SUBJ < >,
			     SPEC < > ],
                       HEAD.MOD < [ LOCAL.CAT [ HEAD verb,
						VAL.SUBJ cons ] ] >,
                       POSTHEAD + ] ] .

adverb-lex := basic-adverb-lex & intersective-mod-lex &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD verb,
						    VAL.SUBJ cons ] ]>,
			   VAL [ SUBJ < >,
				 COMPS < >,
				 SPEC < >,
				 SPR < > ],
			   POSTHEAD + ]]]].

; This grammar includes head-modifier rules.  To keep
; out extraneous parses, constrain the value of MOD on
; various subtypes of head.  This may need to be loosened later.
; This constraint says that only adverbs, adjectives,
; and adpositions can be modifiers.

+nvcdmo :+ [ MOD < > ] .

;;; Coordination Strategy 1

;;; ERB 2007-05-16 We need to get the agreement facts right. I'm 
;;; going to assume that Icelandic behaves like English wrt to person
;;; and number in np coordination.  Don't know what happens with
;;; gender, but that doesn't come into play so much: subject-verb agreement
;;; only does person and number.

;;; ERB 2007-05-16 And furthermore, we can't lose case information,
;;; or we're going to overgenerate like crazy.  Assume for now that
;;; case must be shared between NP conjuncts and mother.  There are
;;; enough constraints in common between np1-top-coord-rule and np1-mid-coord-rule
;;; that it might be nice to refactor.

np1-top-coord-rule := basic-np-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.NUM non-sg,
		   CAT.HEAD.CASE #case,
		   COORD-STRAT "1" ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case ].

np1-mid-coord-rule := basic-np-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE #case, 
		   COORD-STRAT "1" ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case ] .

np1-bottom-coord-rule := conj-first-bottom-coord-rule & np-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.PER #per,
		   CAT.HEAD.CASE #case,
		   COORD-STRAT "1" ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.PER #per,
			    CAT.HEAD.CASE #case ] ].

; ERB 2007-05-16 Too avoid double parses, use 1st-right coord phrase
; in case that both are first person for whatever reason. And 3rd-2nd
; for case where both are second person.

np1-1st-left-coord-rule := coord-phrase &
  [ LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER first,
    RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER non-first,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER first ].

np1-1st-right-coord-rule := coord-phrase &
  [ RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER first,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER first ].
    
np1-2nd-3rd-coord-rule := coord-phrase &
  [ LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER second,
    RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER third,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER second ].

np1-3rd-2nd-coord-rule := coord-phrase &
  [ LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER non-first,
    RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER second,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER second ].

np1-3rd-3rd-coord-rule := coord-phrase &
  [ LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER third,
    RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER third,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER third ].

;;; ERB 2007-05-16 Cross-classify for both top and mid:

np1-mid-1st-left-coord-rule := np1-1st-left-coord-rule & np1-mid-coord-rule.
np1-mid-1st-right-coord-rule := np1-1st-right-coord-rule & np1-mid-coord-rule.
np1-mid-2nd-3rd-coord-rule := np1-2nd-3rd-coord-rule & np1-mid-coord-rule.
np1-mid-3rd-2nd-coord-rule := np1-3rd-2nd-coord-rule & np1-mid-coord-rule.
np1-mid-3rd-3rd-coord-rule := np1-3rd-3rd-coord-rule & np1-mid-coord-rule.

np1-top-1st-left-coord-rule := np1-1st-left-coord-rule & np1-top-coord-rule.
np1-top-1st-right-coord-rule := np1-1st-right-coord-rule & np1-top-coord-rule.
np1-top-2nd-3rd-coord-rule := np1-2nd-3rd-coord-rule & np1-top-coord-rule.
np1-top-3rd-2nd-coord-rule := np1-3rd-2nd-coord-rule & np1-top-coord-rule.
np1-top-3rd-3rd-coord-rule := np1-3rd-3rd-coord-rule & np1-top-coord-rule.






;;; Coordination Strategy 1

;;; ERB 2007-05-16 Coordination needs to preserve MC and INV status.
;;; For now assume that these are just shared between mother and
;;; daughters.   Might need something more fine-grained later, but
;;; we can't just leave them underspecified.

;;; ERB 2007-05-21 New tact: We want to allow the conjuncts to have
;;; different INV values, but the mother should always be [ INV - ],
;;; since we don't want the INT rule up on top.

s1-top-coord-rule := basic-s-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL [ COORD-STRAT "1",
		   CAT [ MC #mc,
			 HEAD.INV - ] ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT.MC #mc ,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

s1-mid-coord-rule := basic-s-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL [ COORD-STRAT "1",
		   CAT [ MC #mc,
			 HEAD.INV #inv ] ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ MC #mc,
				  HEAD.INV #inv ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT [ MC #mc,
				  HEAD.INV #inv ] ].

s1-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "1",
		   CAT [ MC #mc,
			 HEAD.INV #inv ] ],
    COORD-DTR.SYNSEM.LOCAL.CAT [ MC #mc,
				 HEAD.INV #inv ] ].

;;; Copied from English grammar.  

vp-coord-phrase :+
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS < >,
		       HEAD [ FORM #form,
			      INV #inv ] ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD[ FORM #form,
                                      INV #inv ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD [ FORM #form,
                                       INV #inv ] ].

vp-bottom-coord-phrase :+
  [ SYNSEM.LOCAL.CAT.HEAD [ FORM #form,
                            INV #inv ],
    NONCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ FORM #form,
                                        INV #inv ] ].

vp1-top-coord-rule := basic-vp-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

vp1-mid-coord-rule := basic-vp-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

vp1-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .


; For the analysis of inverted yes-no questions, we add the feature INV.

verb :+ [ INV bool ] .

; All verbs start off as not inverted.

verb-lex := basic-verb-lex &
  [ SYNSEM.LOCAL [ CAT [ HEAD.INV -,
                         VAL [ SPR < >,
                               SPEC < >,
                               SUBJ < #subj > ] ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CAT.VAL [ SPR < >,
                                 COMPS < > ],
                       CONT.HOOK.INDEX #xarg ] ], ... > ] .

; Rule for inverted subject verb order in questions.
; The incompatible SUBJ values on SYNSEM and DTR are
; what keeps this one from spinning.

; ERB 2007-05-11 This needs to say the inverted guy is now [ OPT - ],
; to keep the head-opt-comp rule from firing.

subj-v-inv-lrule := cat-change-only-lex-rule & same-hc-light-lex-rule & same-posthead-lex-rule & constant-lex-rule &
  [ SYNSEM [ LOCAL.CAT [ HEAD verb &
                              [ INV + ],
			 VAL [ COMPS < #subj & [ OPT - ] . #comps >,
			       SUBJ < >,
			       SPR #spr,
			       SPEC #spec ],
                         MC na ],
	     LKEYS #lkeys ],
    DTR verb-lex-rules & [ SYNSEM [ LOCAL.CAT.VAL [ SUBJ < #subj >,
				 COMPS #comps,
				 SPR #spr,
				 SPEC #spec ],
		 LKEYS #lkeys ] ] ].

; This rule takes [MC na] inverted phrases and licnesesthem as main clauses with question semantics.
; 

int-cl := interrogative-clause & head-only &
  [ SYNSEM.LOCAL.CAT [ HEAD.INV +,
                       VAL #val,
                       MC + ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ MC na,
                                VAL #val &
                                    [ SUBJ < >,
                                      COMPS < > ] ],
    C-CONT.HOOK.INDEX.SF ques ] .

;;; Relations for demonstratives

demonstrative_a_rel := predsort.
proximal+dem_a_rel := demonstrative_a_rel. ;; close to speaker.
distal+dem_a_rel := demonstrative_a_rel. ;; away from speaker.
remote+dem_a_rel := distal+dem_a_rel. ;;away from speaker and hearer
hearer+dem_a_rel := distal+dem_a_rel. ;;near hearer


;;; Lexical types

;;; Nouns

;;; ERB 2007-05-16 Need to say that the nouns start off not modified.

noun-lex := basic-noun-lex & basic-one-arg & no-hcons-lex-item &
  [ SYNSEM [ LOCAL.CAT.VAL [ COMPS < >,
			     SUBJ < >,
			     SPEC < > ],
	     MODIFIED notmod ] ].

common-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < #spr &
				 [ LOCAL.CAT.HEAD det ] > ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ PER third ],
    ARG-ST < #spr >,
    INFLECTED - ] .
    
fem-noun-lex := common-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ GEND fem ] ].
  
masc-noun-lex := common-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ GEND masc ] ].
  
neut-noun-lex := common-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ GEND neut ] ].
  
m-cl1to3-noun-lex := masc-noun-lex.

m-cl1-noun-lex := m-cl1to3-noun-lex.

m-cl2-noun-lex := m-cl1to3-noun-lex.

m-cl3-noun-lex := m-cl1to3-noun-lex.

m-cl4-noun-lex := masc-noun-lex.

f-cl1-noun-lex := fem-noun-lex.

f-cl2-noun-lex := fem-noun-lex.

f-cl3-noun-lex := fem-noun-lex.

f-cl4-noun-lex := fem-noun-lex.


;;; ERB 2007-05-11 To keep the pronouns out of the indef bare np
;;; rule, we need to give them value for COG-ST.  Going with
;;; activ-or-more, per lab instructions.

pronoun-lex := noun-lex &  
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ OPT + ] >,
		     CONT.HOOK.INDEX.COG-ST activ-or-more ],
	     LKEYS.KEYREL.PRED "_pronoun_n_rel" ] ].

;;; Verbs

head :+ [ AUX bool,
    FORM form ] .

form := avm.

;;; ERB 2007-05-16 For root condition

fin-or-imp := form.

fin := fin-or-imp.

;;; ERB 2007-05-15 Renaming "inf" "supine", since "inf" isn't used
;;; in the grammar, and I'm adding "supine", for the complement of "can".

supine := form.

imp := fin-or-imp.

;;; If there are aspects of the syntax which pick out
;;; lexical Vs (transitive or intransitive) such as V-attachment
;;; of adverbs or argument composition auxiliaries which take V
;;; complements, we need to distinguish (intranstive) V and VP.
;;; To do so, we make use of a feature LIGHT.  Phrases are
;;; generally [LIGHT -] with the exception of head-complement
;;; phrases, which take their value for LIGHT from the head's
;;; HC-LIGHT feature.  To make this work for us here, constraint
;;; HC-LIGHT on verbs to be -.

verb-lex :+ [ SYNSEM.LOCAL.CAT [ HC-LIGHT - ] ].

reg-verb-lex := verb-lex.

trans-verb-lex := reg-verb-lex &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb,
                    	 VAL [ SPR < >,
                               SUBJ < synsem &
					 [ LOCAL.CAT [ HEAD noun &
							   [ CASE nom ],
						      VAL.SPR <> ]] >,
                               SPEC < > ]]],
    INFLECTED - ].


;;; ERB 2007-05-15 Creating two subtypes so we can have "hvort"
;;; ('whether') as well as 'that'.  

;;; ERB 2007-05-16 These guys should insist on finite complements.

complementizer-lex-item := raise-sem-lex-item & basic-one-arg &
  [ SYNSEM.LOCAL.CAT [ HEAD comp,
		       VAL [ SPR < >,
			     SUBJ < >,
			     COMPS < #comps & synsem
				     & [ LOCAL.CAT [ HEAD verb &
							  [ FORM fin ],
						     MC - ] ] > ,
			     SPEC < > ] ],
    ARG-ST < #comps > ].

prop-comp-lex-item := complementizer-lex-item &
   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop ].

ques-comp-lex-item := complementizer-lex-item &
   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques ].



intransitive-verb-lex := reg-verb-lex & intransitive-lex-item &
  [ SYNSEM.LOCAL.CAT [ HEAD verb,
  		       VAL [ SPR < >,
  			     SUBJ < #subj & synsem
  				    & [ LOCAL.CAT [ HEAD noun &
  					 	   	 [ CASE nom ],
  					 	    VAL.SPR <> ] ] >,
  			     COMPS < >,
  			     SPEC < > ]],
    ARG-ST < #subj >,
    INFLECTED - ] .

transitive-verb-lex := trans-verb-lex & transitive-lex-item &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb,
                    	 VAL [ SPR < >,
                               SUBJ < #subj & synsem 
				      & [ LOCAL.CAT [ HEAD noun &
							   [ CASE nom ],
						      VAL.SPR <> ]] >,
                               COMPS < #comps 
				       & [ LOCAL.CAT [ HEAD noun &
							    [ CASE acc ],
						       VAL.SPR <> ],
						   OPT - ]>,
                               SPEC < > ]]],
    ARG-ST < #subj, #comps >,
    INFLECTED - ].

clause-emb-verb-lex := reg-verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb,
                    	 VAL [ SPR < >,
                               SUBJ < #subj & synsem 
				      & [ LOCAL.CAT [ HEAD noun &
							   [ CASE nom ],
						      VAL.SPR <> ]] >,
                               COMPS < #comps 
				       & [ LOCAL.CAT [ HEAD comp,
						       VAL.SPR <> ],
						   OPT - ]>,
                               SPEC < > ]]] ],
    ARG-ST < #subj, #comps >,
    INFLECTED - ].

prop-verb-lex := clause-emb-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.SF prop ].

ques-verb-lex := clause-emb-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.SF ques ].

;;; ERB 2007-05-19 Made OPT-CS type-id here, for GMMT compatibility.
;;; Need a better theory of what it really should be.

opt-trans-verb-lex := trans-verb-lex & transitive-lex-item &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb,
                    	 VAL [ SPR < >,
                               SUBJ < #subj & synsem 
				      & [ LOCAL.CAT [ HEAD noun &
							   [ CASE nom ],
						      VAL.SPR <> ]] >,
                               COMPS < #comps 
				       & [ LOCAL.CAT [ HEAD noun &
							    [ CASE acc ],
						       VAL.SPR <> ],
					   OPT-CS type-id ]>,
                               SPEC < > ]]],
    ARG-ST < #subj, #comps >,
    INFLECTED - ].

ditrans-verb-lex := trans-verb-lex & ditransitive-lex-item &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb,
                    	 VAL [ SPR < >,
                               SUBJ < #subj & synsem 
				      & [ LOCAL.CAT [ HEAD noun &
							   [ CASE nom ],
						      VAL.SPR <> ]] >,
                               COMPS < #comps 
				       & [ LOCAL.CAT [ HEAD noun &
							    [ CASE acc ],
						       VAL.SPR <> ],
						   OPT - ],
				       #comps2
				       & [ LOCAL.CAT [ HEAD noun &
							    [ CASE dat ],
						       VAL.SPR <> ],
					   OPT - ] >,
                               SPEC < > ]]],
    ARG-ST < #subj, #comps, #comps2 >,
    INFLECTED - ]. 

;;; ERB 2007-05-15 It seems that 'can' (our only aux verb so far)
;;; actually takes a past participle ("supine") complement.

aux-verb-lex := verb-lex & trans-first-arg-raising-lex-item-1 &
  [ SYNSEM.LOCAL.CAT [ HEAD verb,
		       VAL [ SUBJ < #subj & synsem
				    & [ LOCAL.CAT [ HEAD noun &
							 [ CASE nom ],
						    VAL.SPR < > ] ] >,
			     COMPS < #comps
				     & [ LOCAL.CAT [ HEAD verb &
							  [ FORM supine ],
						     VAL [ SUBJ < #subj >,
						     	   COMPS < > ] ] ] >,
			     SPR < >,
			     SPEC < > ] ],
    ARG-ST < #subj, #comps >,
    INFLECTED - ].

;;; Case-marking 
;;; ERB 2007-05-11  Add a feature DEF to noun to track whether
;;; nouns are inflected as definite or not.

noun :+ [ CASE case,
	  DEF bool ].

; FORM value for subject marking adpositions.

p-nom := form .

;;; Adjectives

noun :+ [MOD <>].
verb :+ [MOD <>].

;;; ERB 2007-05-11 Katie had the adjectives as lexically prehead,
;;; but really that should depend on whether they get "strong" or
;;; "weak" inflection.

;;; ERB 2007-05-14 On further investigation, I think Katie was right
;;; about this.  Lexically prehead it is. 

adjective-lex := basic-int-mod-adj-lex &
  [ SYNSEM [ LOCAL [ CAT [ POSTHEAD -,
			   HEAD.MOD < [ LOCAL.CAT [ HEAD noun,
						    VAL.SPR cons ]]>,
			   VAL [ SPR < >,
				 SUBJ < >,
				 COMPS < >,
				 SPEC < > ]]]],
    INFLECTED - ].

;;; Determiners
;;; SPEC is non-empty, and already specified by basic-determiner-lex.

;;; ERB 2007-05-11 Assuming that the determiners don't combine
;;; with nouns that have been inflected for definiteness.

;;; ERB 2007-05-11 There's more to be done here.  According to
;;; www.samkoma.com/mimir/mimir.htm, the independent definite determiner
;;; is only used when the noun is preceded by an adjective.  The 
;;; definite suffix is used when there is no adjective or when it
;;; follows the noun.  We could use MODIFIED here to check whether
;;; there are any premodifiers.  In addition, the prehead adjectives
;;; should required [DEF -] on their MOD.  ... Looking a bit further,
;;; it appears that Katie only implemented the prehead modifiers.  
;;; I'm giving MODIFIED a shot to see if it can get the facts right.

;;; ERB 2007-05-11 Again from samkoma.com, it seems that all
;;; adjectives have "weak" and "strong" inflected forms.  The strong
;;; forms appear after the noun and the weak forms appear before the
;;; noun.  From this, it sounds like we need to disallow the weak
;;; forms from indefinite bare np phrases.

;;; ERB 2007-05-14 The strong/weak adjective facts are now handled
;;; by having the strong adjectives say the determiner must be
;;; dropped, and by having the weak adjectives say that the 
;;; interpretation must not be indefinite (i.e., [COG-ST uniq+act+fam]).
;;; No longer need to say anything about SPEC here.  On the other
;;; hand, have this type contribute the exist_q_rel and the COG-ST
;;; value.

;;; ERB 2007-05-16 BUT: The independent determiner can't be used
;;; with a bare noun --- it seems to only be possible (within my limited
;;; dataset anyway) when there is a prenominal adjective.  So, we
;;; do want it to say the SPEC is MODIFIED lmod.

determiner-lex := basic-determiner-lex & basic-zero-arg &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < >,
			     COMPS < >,
			     SPEC < [ LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act,
				      MODIFIED lmod ] >,
			     SUBJ < > ],
	     LKEYS.KEYREL.PRED "exist_q_rel" ]].

sg-det-lex := determiner-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX.PNG.NUM sg ] > ].

pl-det-lex := determiner-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX.PNG.NUM non-sg ] > ].

m+n-det-lex := determiner-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX.PNG.GEND masc+neut ] > ].

m-det-lex := determiner-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX.PNG.GEND masc ] > ].

f-det-lex := determiner-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX.PNG.GEND fem ] > ].

n-det-lex := determiner-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX.PNG.GEND neut ] > ].

nom+acc-det-lex := determiner-lex & 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.CASE nom+acc ] > ].

nom-det-lex := nom+acc-det-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.CASE nom ] > ].

acc-det-lex := nom+acc-det-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.CASE acc ] > ].

dat-det-lex := determiner-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.CASE dat ] > ].

gen-det-lex := determiner-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.CASE gen ] > ].

;;; ERB 2007-05-11 Cross-classified types for instances.  Note
;;; that there is some syncretism, so we're not getting the full
;;; cross-classification.

sg-m-nom+acc-det-lex := sg-det-lex & m-det-lex & nom+acc-det-lex.
sg-m-dat-det-lex := sg-det-lex & m-det-lex & dat-det-lex.
sg-m+n-gen-det-lex := sg-det-lex & m+n-det-lex & gen-det-lex.

sg-f-nom-det-lex := sg-det-lex & f-det-lex & nom-det-lex.
sg-f-acc-det-lex := sg-det-lex & f-det-lex & nom-det-lex.
sg-f-dat-det-lex := sg-det-lex & f-det-lex & dat-det-lex.
sg-f-gen-det-lex := sg-det-lex & f-det-lex & gen-det-lex.

sg-n-nom+acc-det-lex := sg-det-lex & n-det-lex & nom+acc-det-lex.
sg-n-dat-det-lex := sg-det-lex & n-det-lex & dat-det-lex.

pl-m-nom-det-lex := pl-det-lex & m-det-lex & nom-det-lex.
pl-m-acc-det-lex := pl-det-lex & m-det-lex & acc-det-lex.

pl-f-nom+acc-det-lex := pl-det-lex & f-det-lex & nom+acc-det-lex.

pl-n-nom+acc-det-lex := pl-det-lex & n-det-lex & nom+acc-det-lex.

pl-dat-det-lex := pl-det-lex & dat-det-lex.
pl-gen-det-lex := pl-det-lex & gen-det-lex.


;;; ERB 2007-05-11 Adding demonstrative determiners for GMMT.
;;; Or one demonstrative determiner, anyway.

demonstrative-determiner-lex := norm-hook-lex-item & basic-zero-arg &
[ SYNSEM [ LOCAL [CAT [ HEAD det,
	VAL[ SPEC.FIRST.LOCAL[ CONT.HOOK [ INDEX #ind & [COG-ST activ+fam],
					   LTOP #larg & #lbl],
			       CAT.HEAD.DEF - ],
	SPR < >,
	SUBJ < >,
	COMPS < >]],
CONT [ HCONS < ! qeq & 
	[ HARG #harg,
	LARG #larg ] ! >, RELS <![ PRED "exist_q_rel"], #lkey & arg1-relation & [LBL #lbl,
 ARG1 #ind] ! >] ] ,
LKEYS [ KEYREL quant-relation &
	[ ARG0 #ind,
	RSTR #harg ], ALTKEYREL #lkey]]].





png :+ [ PER person,
	 NUM number,
	 GEND gender ].

person := *top*.
first := person.
non-first := person.
second := non-first.
third := non-first.

number := *top*.
sg := number.
non-sg := number.
pl := non-sg.

gender := avm.
masc+neut := gender.
masc := masc+neut.
fem := gender.
neut: = masc+neut.

case := *top*.
notnom := case.
nom+acc := case.
acc+dat := notnom.
nom := nom+acc.
acc := acc+dat & nom+acc.
dat := acc+dat.
gen := notnom.

present := tense.
future := tense.
past := tense.

;;; Lexical rules

; ERB 2007-05-11 Add [ DEF + ] here to track whether these
; rules have applied.

; ERB 2007-05-14 Actually don't need [ DEF + ] here, just
; contrasting [ DEF - ] on the indef rule.  Do need to say
; that the SPR is now obligatory.  (This could perhaps be done
; with DEF + instead, making the head-spec rule check for [ DEF - ],
; but that might get in the way when we want to use the head-spec
; rule for other constructions.

det-lex-rule := infl-ltow-rule &
 [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ OPT + ] >,
		  CONT.HOOK.INDEX.COG-ST uniq+fam+act ] ].

nom-sg-det-lex-rule := det-lex-rule &
  [ DTR nom-sg-lex-rule ].

nom-pl-det-lex-rule := det-lex-rule &
  [ DTR nom-pl-lex-rule ].

acc-sg-det-lex-rule := det-lex-rule &
  [ DTR acc-sg-lex-rule ].

acc-pl-det-lex-rule := det-lex-rule &
  [ DTR acc-pl-lex-rule ].

dat-sg-det-lex-rule := det-lex-rule &
  [ DTR dat-sg-lex-rule ].

dat-pl-det-lex-rule := det-lex-rule &
  [ DTR dat-pl-lex-rule ].

m-nom-sg-det-lex-rule := nom-sg-det-lex-rule &
  [ DTR m-nom-sg-lex-rule ].

m-nom-pl-det-lex-rule := nom-pl-det-lex-rule &
  [ DTR m-nom-pl-lex-rule ].

m-acc-sg-det-lex-rule := acc-sg-det-lex-rule &
  [ DTR m-acc-sg-lex-rule ].

m-acc-pl-det-lex-rule := acc-pl-det-lex-rule &
  [ DTR m-acc-pl-lex-rule ].

m-dat-sg-det-lex-rule := dat-sg-det-lex-rule &
  [ DTR m-dat-sg-lex-rule ].

m-dat-pl-det-lex-rule := dat-pl-det-lex-rule &
  [ DTR m-dat-pl-lex-rule ].

f-nom-sg-det-lex-rule := nom-sg-det-lex-rule &
  [ DTR f-nom-sg-lex-rule ].

f-acc-sg-det-lex-rule := acc-sg-det-lex-rule &
  [ DTR f-acc-sg-lex-rule ].

f-dat-sg-det-lex-rule := dat-sg-det-lex-rule &
  [ DTR f-dat-sg-lex-rule ].

n-nom-sg-det-lex-rule := nom-sg-det-lex-rule &
  [ DTR n-nom-sg-lex-rule ].

n-acc-sg-det-lex-rule := acc-sg-det-lex-rule &
  [ DTR n-acc-sg-lex-rule ].

n-dat-sg-det-lex-rule := dat-sg-det-lex-rule &
  [ DTR n-dat-sg-lex-rule ].

; ERB 2007-05-11 Adding [DEF -] here to keep these out of
; the definite bare np rule.  Removing [ COG-ST type-id ],
; since that is now added by the indef-bare-np-phrase, if 
; at all.

indef-det-lex-rule := const-ltow-rule &
  [ DTR num+case-lex-rule,
    SYNSEM.LOCAL.CAT.HEAD.DEF - ].

num+case-lex-rule := add-only-no-ccont-rule.

nom-sg-lex-rule := num+case-lex-rule &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE nom,
		   CONT.HOOK.INDEX.PNG [ NUM sg ] ] ].

nom-pl-lex-rule := num+case-lex-rule &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE nom,
		   CONT.HOOK.INDEX.PNG [ NUM non-sg ] ] ].

acc-sg-lex-rule := num+case-lex-rule &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
		   CONT.HOOK.INDEX.PNG [ NUM sg ] ] ].

acc-pl-lex-rule := num+case-lex-rule &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
		   CONT.HOOK.INDEX.PNG [ NUM non-sg ] ] ].

dat-sg-lex-rule := num+case-lex-rule &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE dat,
		   CONT.HOOK.INDEX.PNG [ NUM sg ] ] ].

dat-pl-lex-rule := num+case-lex-rule &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE dat,
		   CONT.HOOK.INDEX.PNG [ NUM non-sg ] ] ].

infl-nom-sg-lex-rule := infl-ltol-rule & nom-sg-lex-rule.

const-nom-sg-lex-rule := const-ltol-rule & nom-sg-lex-rule.

infl-nom-pl-lex-rule := infl-ltol-rule & nom-pl-lex-rule.

const-acc-sg-lex-rule := const-ltol-rule & acc-sg-lex-rule.
    			   
infl-acc-sg-lex-rule := infl-ltol-rule & acc-sg-lex-rule.

infl-acc-pl-lex-rule := infl-ltol-rule & acc-pl-lex-rule.

infl-dat-sg-lex-rule := infl-ltol-rule & dat-sg-lex-rule.

const-dat-sg-lex-rule := const-ltol-rule & dat-sg-lex-rule.

infl-dat-pl-lex-rule := infl-ltol-rule & dat-pl-lex-rule.

m-nom-sg-lex-rule := nom-sg-lex-rule &
  [ DTR masc-noun-lex ] .

m-nom-pl-lex-rule := nom-pl-lex-rule &
  [ DTR masc-noun-lex ] .

m-acc-sg-lex-rule := acc-sg-lex-rule &
  [ DTR masc-noun-lex ] .

m-acc-pl-lex-rule := acc-pl-lex-rule &
  [ DTR masc-noun-lex ] .

m-dat-sg-lex-rule := dat-sg-lex-rule &
  [ DTR masc-noun-lex ] .

m-dat-pl-lex-rule := dat-pl-lex-rule &
  [ DTR masc-noun-lex ] .

f-nom-sg-lex-rule := nom-sg-lex-rule &
  [ DTR fem-noun-lex ] .

f-acc-sg-lex-rule := acc-sg-lex-rule &
  [ DTR fem-noun-lex ] .

f-dat-sg-lex-rule := dat-sg-lex-rule &
  [ DTR fem-noun-lex ] .

n-nom-sg-lex-rule := nom-sg-lex-rule &
  [ DTR neut-noun-lex ] .

n-acc-sg-lex-rule := acc-sg-lex-rule &
  [ DTR neut-noun-lex ] .

n-dat-sg-lex-rule := dat-sg-lex-rule &
  [ DTR neut-noun-lex ] .
  
m-clto3-sg-nom-lex-rule := infl-nom-sg-lex-rule & m-nom-sg-lex-rule &
  [ DTR m-cl1to3-noun-lex ] .

m-clto3-pl-nom-lex-rule := infl-nom-pl-lex-rule & m-nom-pl-lex-rule &
  [ DTR m-cl1to3-noun-lex ] .
  
m-clto3-sg-acc-lex-rule := const-acc-sg-lex-rule & m-acc-sg-lex-rule &
  [ DTR m-cl1to3-noun-lex ] .

m-clto3-pl-acc-lex-rule := infl-acc-pl-lex-rule & m-acc-pl-lex-rule &
  [ DTR m-cl1to3-noun-lex ] .

; ERB 2007-05-11: Added plural rules for class one (dog, car)

m-cl1-nom-pl-lex-rule := m-nom-pl-lex-rule & infl-nom-pl-lex-rule &
  [ DTR m-cl1-noun-lex ].
  
m-cl1-acc-pl-lex-rule := m-acc-pl-lex-rule & infl-acc-pl-lex-rule &
  [ DTR m-cl1-noun-lex ].

; ERB 2007-05-11: And for class three (cat)

m-cl3-nom-pl-lex-rule := m-nom-pl-lex-rule & infl-nom-pl-lex-rule &
  [ DTR m-cl3-noun-lex ].
  
m-cl3-acc-pl-lex-rule := m-acc-pl-lex-rule & infl-acc-pl-lex-rule &
  [ DTR m-cl3-noun-lex ].



m-cl4-lex-rule := num+case-lex-rule & const-ltol-rule &
  [ DTR m-cl4-noun-lex ] .

m-cl1-sg-dat-lex-rule := infl-dat-sg-lex-rule & m-dat-sg-lex-rule &
  [ DTR m-cl1-noun-lex ] .

m-cl2-sg-dat-lex-rule := const-dat-sg-lex-rule & m-dat-sg-lex-rule &
  [ DTR m-cl2-noun-lex ] .

m-cl3-sg-dat-lex-rule := infl-dat-sg-lex-rule & m-dat-sg-lex-rule &
  [ DTR m-cl3-noun-lex ] .

m-cl1to3-pl-dat-lex-rule := infl-dat-pl-lex-rule & m-dat-pl-lex-rule &
  [ DTR m-cl1to3-noun-lex ] .
  
f-cl1-sg-nom-lex-rule := const-nom-sg-lex-rule & f-nom-sg-lex-rule &
  [ DTR f-cl1-noun-lex ] .
  
f-cl1-sg-acc-lex-rule := infl-acc-sg-lex-rule & f-acc-sg-lex-rule &
  [ DTR f-cl1-noun-lex ] .

f-cl1-sg-dat-lex-rule := infl-dat-sg-lex-rule & f-dat-sg-lex-rule &
  [ DTR f-cl1-noun-lex ].

f-cl3-sg-nom-lex-rule := const-nom-sg-lex-rule & f-nom-sg-lex-rule &
  [ DTR f-cl3-noun-lex ].

f-cl3-sg-acc-lex-rule := const-acc-sg-lex-rule & f-acc-sg-lex-rule &
  [ DTR f-cl3-noun-lex ].

f-cl3-sg-dat-lex-rule := const-dat-sg-lex-rule & f-dat-sg-lex-rule &
  [ DTR f-cl3-noun-lex ].

n-sg-nom-lex-rule := const-nom-sg-lex-rule & n-nom-sg-lex-rule &
  [ DTR neut-noun-lex ] .

n-sg-acc-lex-rule := const-acc-sg-lex-rule & n-acc-sg-lex-rule &
  [ DTR neut-noun-lex ] .

n-sg-dat-lex-rule := infl-dat-sg-lex-rule & n-dat-sg-lex-rule &
  [ DTR neut-noun-lex ] .

verb-lex-rules := add-only-no-ccont-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM fin ].

num+pers-lex-rule := verb-lex-rules &
  [ DTR reg-verb-lex ].

infl-verb := num+pers-lex-rule & infl-ltow-rule.

const-verb := num+pers-lex-rule & const-ltow-rule.
  
1sg_verb-lex-rule := const-verb &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER first,
							      NUM sg ]] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb ].
    
1pl_verb-lex-rule := infl-verb &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER first,
							      NUM non-sg ]] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb ].
    
2sg_verb-lex-rule := infl-verb &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER second,
							      NUM sg ]] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb ].
    
2pl_verb-lex-rule := infl-verb &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER second,
							      NUM non-sg ]] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

3sg_verb-lex-rule := infl-verb &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER third,
							      NUM sg ]] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb ].  
    
3pl_verb-lex-rule := const-verb &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER third,
							      NUM non-sg ]] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

imp-lex-rule := add-only-no-ccont-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM imp,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

2-sg-imp-lex-rule := imp-lex-rule & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER second,
							      NUM sg ]] > ].

2-pl-imp-lex-rule := imp-lex-rule & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER second,
							      NUM non-sg ]] > ].

1-pl-imp-lex-rule := imp-lex-rule & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER first,
							      NUM non-sg ]] > ].
aux-lex-rule := verb-lex-rules &
  [ DTR aux-verb-lex ].

1-sg-aux-lex-rule := aux-lex-rule & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER first,
							      NUM sg ] ] > ].

1-pl-aux-lex-rule := aux-lex-rule & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER first,
							      NUM non-sg ] ] > ].

2-sg-aux-lex-rule := aux-lex-rule & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER second,
							      NUM sg ] ] > ].

2-pl-aux-lex-rule := aux-lex-rule & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER second,
							      NUM non-sg ] ] > ].

3-sg-aux-lex-rule := aux-lex-rule & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER third,
							      NUM sg ] ] > ].

3-pl-aux-lex-rule := aux-lex-rule & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER third,
							      NUM non-sg ] ] > ].

adj-lex-rule := infl-ltow-rule &
  [ DTR adjective-lex ].

;;; ERB 2007-05-15 Adding a lexical rule for "supine" verbs.  Not
;;; bothering with morphophonology, just putting the one in for the
;;; class containing "eat".

;;; ERB 2007-05-16 Forgot to constrain FORM here.

supine-verb-lex-rule := infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM supine,
    DTR reg-verb-lex ].

;;; ERB 2007-05-11 Moving posthead constraint here.

;;; ERB 2007-05-14 In fact, all adjectives (strong or weak) are
;;; probably prehead (according to the judgments I got for *one*
;;; adjective from Gunnar, anyway).  Moving that back to adjective-lex.
;;; Meanwhile, adding constraints to require weak adjectives to combine
;;; with definites only.  Definiteness can be expressed by either
;;; an independent determiner (definite article or demonstrative) or
;;; by an inflectional affix.

weak-adj-lex-rule := adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act ] > ].

weak-pl-adj-lex-rule := weak-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ NUM non-sg ] ] > ].

weak-sg-adj-lex-rule := weak-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ NUM sg ] ] > ].

weak-m-lex-rule := weak-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEND masc ] ] > ].

weak-f-lex-rule := weak-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEND fem ] ] > ].

weak-n-lex-rule := weak-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEND neut ] ] > ].

weak-nom-lex-rule := weak-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.CASE nom ] > ].

weak-acc-lex-rule := weak-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.CASE acc ] > ].

weak-dat-lex-rule := weak-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.CASE dat ] > ].

weak-m-sg-nom-adj-lex-rule := weak-m-lex-rule & weak-sg-adj-lex-rule & weak-nom-lex-rule.

weak-m-sg-acc-adj-lex-rule := weak-m-lex-rule & weak-sg-adj-lex-rule & weak-acc-lex-rule.

weak-m-sg-dat-adj-lex-rule := weak-m-lex-rule & weak-sg-adj-lex-rule & weak-dat-lex-rule.

weak-f-sg-acc-adj-lex-rule := weak-f-lex-rule & weak-sg-adj-lex-rule & weak-acc-lex-rule.

weak-f-sg-dat-adj-lex-rule := weak-f-lex-rule & weak-sg-adj-lex-rule & weak-dat-lex-rule.

weak-f-sg-nom-adj-lex-rule := weak-f-lex-rule & weak-sg-adj-lex-rule & weak-nom-lex-rule.

weak-n-sg-adj-lex-rule := weak-n-lex-rule & weak-sg-adj-lex-rule.

; ERB 2007-05-11 adding the strong adjective inflection.
; There's actually two inflectional classes here.  For now, I'm
; just implementing the class which includes svang- `hungry'.

; ERB 2007-05-14 According to Gunnar O. Svang- at least is prehead
; whether it is strong or weak.  In addition, strong adjectives can
; co-occur with nouns inflected for definiteness (with an interesting
; contrast in meaning which I'm not modeling), but not with overt
; determiners.  Accordingly, making adjective-lex once again [
; POSTHEAD - ] and making MOD's SPR be obligatorily "dropped" here
; ([OPT +], in the way that I'm abusing that feature).

strong-adj-lex-rule := lexeme-to-word-rule &
  [ DTR adjective-lex,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SPR < [ OPT + ] > ] > ].

sg-strong-adj-lex-rule := strong-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG.NUM sg ] > ].

pl-strong-adj-lex-rule := strong-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG.NUM non-sg ] > ].

f-strong-adj-lex-rule := strong-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG.GEND fem ] > ].

m-strong-adj-lex-rule := strong-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG.GEND masc ] > ].

n-strong-adj-lex-rule := strong-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG.GEND neut ] > ].

nom-strong-adj-lex-rule := strong-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.CASE nom ] > ].

acc-strong-adj-lex-rule := strong-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.CASE acc ] > ].

dat-strong-adj-lex-rule := strong-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.CASE dat ] > ].

gen-strong-adj-lex-rule := strong-adj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.CASE gen ] > ].

;; Make cross product, then create instances.

f-sg-nom-strong-adj-lex-rule := f-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				nom-strong-adj-lex-rule &
				const-ltow-rule.

f-sg-acc-strong-adj-lex-rule := f-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				acc-strong-adj-lex-rule &
				infl-ltow-rule.

f-sg-dat-strong-adj-lex-rule := f-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				dat-strong-adj-lex-rule &
				infl-ltow-rule.

f-sg-gen-strong-adj-lex-rule := f-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				gen-strong-adj-lex-rule &
				infl-ltow-rule.

f-pl-nom-strong-adj-lex-rule := f-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				nom-strong-adj-lex-rule &
				infl-ltow-rule.

f-pl-acc-strong-adj-lex-rule := f-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				acc-strong-adj-lex-rule &
				infl-ltow-rule.

f-pl-dat-strong-adj-lex-rule := f-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				dat-strong-adj-lex-rule &
				infl-ltow-rule.

f-pl-gen-strong-adj-lex-rule := f-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				gen-strong-adj-lex-rule &
				infl-ltow-rule.

m-sg-nom-strong-adj-lex-rule := m-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				nom-strong-adj-lex-rule &
				infl-ltow-rule.

m-sg-acc-strong-adj-lex-rule := m-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				acc-strong-adj-lex-rule &
				infl-ltow-rule.

m-sg-dat-strong-adj-lex-rule := m-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				dat-strong-adj-lex-rule &
				infl-ltow-rule.

m-sg-gen-strong-adj-lex-rule := m-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				gen-strong-adj-lex-rule &
				infl-ltow-rule.

m-pl-nom-strong-adj-lex-rule := m-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				nom-strong-adj-lex-rule &
				infl-ltow-rule.

m-pl-acc-strong-adj-lex-rule := m-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				acc-strong-adj-lex-rule &
				infl-ltow-rule.

m-pl-dat-strong-adj-lex-rule := m-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				dat-strong-adj-lex-rule &
				infl-ltow-rule.

m-pl-gen-strong-adj-lex-rule := m-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				gen-strong-adj-lex-rule &
				infl-ltow-rule.

n-sg-nom-strong-adj-lex-rule := n-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				nom-strong-adj-lex-rule &
				infl-ltow-rule.

n-sg-acc-strong-adj-lex-rule := n-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				acc-strong-adj-lex-rule &
				infl-ltow-rule.

n-sg-dat-strong-adj-lex-rule := n-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				dat-strong-adj-lex-rule &
				infl-ltow-rule.

n-sg-gen-strong-adj-lex-rule := n-strong-adj-lex-rule & 
				sg-strong-adj-lex-rule &
				gen-strong-adj-lex-rule &
				infl-ltow-rule.

n-pl-nom-strong-adj-lex-rule := n-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				nom-strong-adj-lex-rule &
				const-ltow-rule.

n-pl-acc-strong-adj-lex-rule := n-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				acc-strong-adj-lex-rule &
				const-ltow-rule.

n-pl-dat-strong-adj-lex-rule := n-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				dat-strong-adj-lex-rule &
				infl-ltow-rule.

n-pl-gen-strong-adj-lex-rule := n-strong-adj-lex-rule & 
				pl-strong-adj-lex-rule &
				gen-strong-adj-lex-rule &
				infl-ltow-rule.
