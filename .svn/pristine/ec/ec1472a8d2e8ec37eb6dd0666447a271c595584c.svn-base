;Hebrew 2-6-07

; We can't just use the V-final and V-initial word
; order modules together to get a good free word order
; module. The root of the problem seems to be that we
; need the subject to be able to attach inside the
; object(s) for VSO and OSV, but at the same time, we
; don't want complete flexibility on order of attachment
; when the verb is in the middle -- that would give
; spurious ambiguity.  This solution adopts the xmod
; hierarchy to enforce right-first attachment.  That is,
; all arguments appears to the right of the verb must
; attach before all arguments appearing to the left.  The
; linguistic prediction of this analysis is that free
; word order languages do not have a consistent VP
; consituent, even when the verb and object are adjacent
; (OV order).  Using a separate feature for tracking
; argument attachment (as opposed to modifier
; attachment).  We might be able to collapse these one
; day, but that's not obvious.

synsem :+ [ ATTACH xmod ] .

head-initial-head-nexus := head-initial &
  [ SYNSEM.ATTACH lmod,
    HEAD-DTR.SYNSEM.ATTACH notmod-or-lmod ] .

head-final-head-nexus := head-final &
  [ SYNSEM.ATTACH rmod ] .

; We'll need to add identification of ATTACH between
; mother and head-daughter for all other kinds of phrases
; if we do this.  Just for illustration, I'm putting it
; in for head-adjunct phrases here:

head-mod-phrase :+ [ SYNSEM.ATTACH #attach,
    HEAD-DTR.SYNSEM.ATTACH #attach ] .

;;;I'm constraining these so that the verb FORM is fin (do I also need to make the subj nom?). Anyway this will have to be revised later to accommodate verbless sentences and non-finite verb sentences

head-subj-phrase := decl-head-subj-phrase & head-initial-head-nexus &
 [ SYNSEM.LOCAL.CAT.HEAD verb & [ FORM fin ] ] .

subj-head-phrase := decl-head-subj-phrase & head-final-head-nexus &
 [ SYNSEM.LOCAL.CAT.HEAD verb & [ FORM fin ] ] .

head-comp-phrase := basic-head-1st-comp-phrase & head-initial-head-nexus .

; The head of comp-head-phrase can't be: ['adp', 'comp']

;comp-head-phrase := basic-head-1st-comp-phrase & head-final-head-nexus &
;  [ SYNSEM.LOCAL.CAT.HEAD +nvjrdmo ] .

;;For now I am constraining it further assuming that only comps of a verb may precede it
comp-head-phrase := basic-head-1st-comp-phrase & head-final-head-nexus &
  [ SYNSEM.LOCAL.CAT.HEAD verb ] .

head-comp-phrase-2 := basic-head-2nd-comp-phrase & head-initial-head-nexus .

comp-head-phrase-2 := basic-head-2nd-comp-phrase & head-final-head-nexus .

; Rules for bulding NPs.  Note that the Matrix uses SPR for
;                the specifier of nouns and SUBJ for the subject (specifier) of verbs.

;head-spec-phrase := basic-head-spec-phrase & head-final .
spec-head-phrase := basic-head-spec-phrase & head-final.


; This grammar includes head-modifier rules.  To keep
; out extraneous parses, constrain the value of MOD on
; various subtypes of head.  This may need to be loosened later.
; This constraint says that only adverbs, adjectives,
; and adpositions can be modifiers.

+nvcdmo :+ [ MOD < > ] .

;;; Coordination Strategy 1

;n1-top-coord-rule := basic-n-top-coord-rule & monopoly-top-coord-rule &
;  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

;n1-mid-coord-rule := basic-n-mid-coord-rule & monopoly-mid-coord-rule &
;  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

;n1-bottom-coord-rule := conj-first-bottom-coord-rule & n-bottom-coord-phrase &
;  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

;;; Coordination Strategy 1

np1-top-coord-rule := basic-np-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1",
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [NUM non-sg] ] .

np1-mid-coord-rule := basic-np-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

np1-bottom-coord-rule := conj-first-bottom-coord-rule & np-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

;;; Coordination Strategy 1

vp1-top-coord-rule := basic-vp-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM #form,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM #form,
    SYNSEM.LOCAL.CAT.HEAD.FORM #form] .

vp1-mid-coord-rule := basic-vp-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1",
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM #form,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM #form,
    SYNSEM.LOCAL.CAT.HEAD.FORM #form] .

vp1-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1",
    NONCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM #form,
    SYNSEM.LOCAL.CAT.HEAD.FORM #form] .

;;; Coordination Strategy 1

s1-top-coord-rule := basic-s-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

s1-mid-coord-rule := basic-s-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

s1-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

;;;this was needed in the old grammar for the embedded comp not to head a matrix clause
;;;need to do something nicer
head-comp-phrase :+ [ SYNSEM.LOCAL.CAT.MC #mc,
		      HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ] .

; We treat question particles as complementizers.
; Here is the lexical type for complementizers.

comp :+ [ COMPLEMENTIZER-TYPE complementizer-type ].
complementizer-type := *top*.
embedded-complementizer := complementizer-type.
main-complementizer:= complementizer-type.
interrogative-complementizer := complementizer-type.
declarative-complementizer := complementizer-type.
embedded-interrogative-complementizer := embedded-complementizer & interrogative-complementizer.
embedded-declarative-complementizer := embedded-complementizer & declarative-complementizer.
main-interrogative-complementizer := main-complementizer & interrogative-complementizer.

complementizer-lex-item := raise-sem-lex-item & basic-one-arg &
  [ SYNSEM.LOCAL.CAT [ HEAD comp &
                            [ MOD < > ],
                       VAL [ SPR < >,
                             SUBJ < >,
                             COMPS < #comp > ] ],
    ARG-ST < #comp &
             [ LOCAL.CAT [ HEAD verb & [ FORM fin ],
                           VAL [ SUBJ < >,
                                 COMPS < > ] ] ] > ] .

main-complementizer-lex-item := complementizer-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.MC + ] > ] .

embedded-complementizer-lex-item := complementizer-lex-item &
  [ SYNSEM.LOCAL.CAT [ MC #mc, 
	               VAL.COMPS < [ LOCAL.CAT.MC -,
                                     LOCAL.CAT.MC #mc ] > ] ].

; Subtype for question particles. Constrains SF to ques.

interrogative-complementizer-lex-item := complementizer-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques ] .

declarative-complementizer-lex-item := complementizer-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop ] .

embedded-interrogative-complementizer-lex-item := embedded-complementizer-lex-item & interrogative-complementizer-lex-item .

embedded-declarative-complementizer-lex-item := embedded-complementizer-lex-item & declarative-complementizer-lex-item .

main-interrogative-complementizer-lex-item := main-complementizer-lex-item & interrogative-complementizer-lex-item . 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;             NPs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

synsem :+  [ INFLECTED-FOR-NUMBER bool].

demonstrative_a_rel := predsort.
proximal+dem_a_rel := demonstrative_a_rel. ; close to speaker
distal+dem_a_rel := demonstrative_a_rel.   ; away from speaker
remote+dem_a_rel := distal+dem_a_rel.      ; away from speaker and hearer
hearer+dem_a_rel := distal+dem_a_rel.      ; near hearer

;quantifier_rel := predsort.
;pronoun_q_rel := quantifier_rel.
;proper_q_rel := quantifier_rel.
;;reg_quant_rel := quantifier_rel.
;demonstrative_q_rel := quantifier_rel.
;non+demonstrative_q_rel := quantifier_rel.
;def_q_rel := non+demonstrative_q_rel.
;indef_q_rel := non+demonstrative_q_rel.

;all_quant_rel := reg_quant_rel.

canonical-synsem :+ [ MODORDER modorder ].

lex-rule :+ 
  [ SYNSEM.MODORDER #modorder,
    DTR.SYNSEM.MODORDER #modorder ].

;;as it stands dem is incompatible with def & indef
;modorder := avm.
;def-indef-modorder := modorder.
;indef-modorder := def-indef-modorder.
;def-modorder := def-indef-modorder.
;adj-dem-modorder := modorder.
;adj-modorder := adj-dem-modorder.
;dem-modorder := adj-dem-modorder.
;indef-adj-modorder := adj-modorder & indef-modorder.
;def-adj-modorder := adj-modorder & def-modorder.
;indef-dem-modorder := dem-modorder & indef-modorder.
;def-dem-modorder := dem-modorder & def-modorder.

modorder := avm.
adj-modorder := modorder.
dem-modorder := modorder.

;canonical-synsem :+ [ DEF-INDEF def-indef ].

;def-indef := avm. 
;indef := def-indef.
;def := def-indef.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS <! [ PRED "exist_q_rel" ] !> ].

;;h-klb, h-klb h-ryb, hwa
def-bare-np-phrase := bare-np-phrase &
  [ HEAD-DTR.SYNSEM [ MODORDER adj-modorder ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ DEF-INDEF def ] ].

;;klb, klb ryb
non-dem-indef-bare-np-phrase := bare-np-phrase &
  [ HEAD-DTR.SYNSEM [ MODORDER adj-modorder ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST type-id,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ DEF-INDEF indef ] ] .

;;klb zh, h-klb h-zh 
dem-bare-np-phrase := bare-np-phrase &
  [ HEAD-DTR.SYNSEM [ MODORDER dem-modorder ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON common,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST activ+fam ].

;;zh
dem-pronoun-np-phrase := bare-np-phrase &
  [ HEAD-DTR.SYNSEM [ MODORDER adj-modorder ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON it_pronoun,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST activ+fam ].
    
    
;;; Determiners
;;; SPEC is non-empty, and already specified by basic-determiner-lex.

determiner-lex-supertype := norm-hook-lex-item & basic-zero-arg &
  [ SYNSEM [ LOCAL [ CAT [ HEAD det,
			   VAL[ SPEC.FIRST.LOCAL.CONT.HOOK [ INDEX #ind,
				  			     LTOP #larg ],
                                SPR < >,
                                SUBJ < >,
                                COMPS < >]],
		     CONT.HCONS < ! qeq &
				 [ HARG #harg,
				   LARG #larg ] ! > ], 
	     LKEYS.KEYREL quant-relation &
		   [ ARG0 #ind,
		     RSTR #harg ] ] ].


non-dem-det-lex := determiner-lex-supertype &
 [ SYNSEM.LOCAL.CONT.RELS <! relation !> ].


;;;These are the lexical types - I made the pronoun and proper nouns COG-ST uniq+fam+act so as to prevent them from going through the indef-noun-rule. But I don't want them to undergo the "h" insertion rule either. It seems ugly to list these RELS constraints in the irules, so I am creating for now a new feature for pronouns & propers. This actually makes the COG-ST uniq+fam+act restriction redundant but Emily will probably tell me to get rid of the ppc anyway.

noun :+ [ PROPER_PRONOUN_COMMON ppc ].
ppc := *top*.
proper_or_pronoun := ppc.
pronoun := proper_or_pronoun.
proper := proper_or_pronoun & not_personal_pronoun.
personal_pronoun := pronoun.
not_personal_pronoun := ppc.
common := not_personal_pronoun.
it_pronoun := not_personal_pronoun & pronoun.

noun-lex-supertype := basic-one-arg & norm-hook-lex-item &
  [ SYNSEM [ LOCAL.CAT [ HEAD noun,
                         VAL [ SPR < #spr &
                                   [ LOCAL.CAT.HEAD det ] >,
                               COMPS < >,
                               SUBJ < >,
                               SPEC < > ]],
             INFLECTED-FOR-NUMBER -, 
             LKEYS.KEYREL noun-relation ],
    INFLECTED  -, 
    ARG-ST < #spr > ] .

noun-lex := noun-lex-supertype & single-rel-lex-item & no-hcons-lex-item.

pronoun-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT + ] > ,  
    SYNSEM.LKEYS.KEYREL.PRED "_pronoun_n_rel" ,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ COG-ST activ-or-more, 
				   SPECI + ]].

personal-pronoun-lex := pronoun-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act,
  SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON personal_pronoun,
  SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ DEF-INDEF def ] ].


demonstrative-pronoun-lex := noun-lex-supertype & 
[ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT + ] > ,
  SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST activ+fam,
  SYNSEM.LOCAL.CONT.HOOK.INDEX #index,
  SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
  SYNSEM.LKEYS.KEYREL.PRED #pronoun,
  SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON it_pronoun,
  SYNSEM.LOCAL.CONT.RELS < ![ PRED #pronoun ] , #event-relation & [ARG1 #index]! > ,
  SYNSEM.LKEYS.ALTKEYREL arg1-ev-relation & #event-relation & [ LBL #lbl ],
  SYNSEM.LOCAL.CONT.HCONS <! !> ].
  
common-noun-lex := noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER third ] ],
    SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON common ].

proper-noun-lex := noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER third ] ],
    SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON proper,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act ].
  
;;;These are the phrase types

;pronoun-bare-np-phrase := basic-bare-np-phrase &
;  [ C-CONT.RELS < ! [ PRED "pronoun_q_rel" ] ! > ].

;common-bare-np-phrase := basic-bare-np-phrase &
; [ C-CONT.RELS < ! [ PRED  "reg_quant_rel" ] ! > ].
 
;proper-bare-np-phrase := basic-bare-np-phrase &
;  [ C-CONT.RELS < ! [ PRED  "proper_q_rel" ] ! > ].

;;;adjectives

;;the reason we placed the restriction on the MOD's SPR that it be non-empty is because we want to prevent the adjective-lex from attaching to NP; this way, it may only attach to Nom

adjective-lex := basic-adjective-lex & norm-sem-lex-item & no-hcons-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj &
				[ MOD < [ LOCAL [ CAT.HEAD noun,
							 CAT.VAL.SPR 1-list,
							 CONT.HOOK [ INDEX #ind,
								     LTOP #ltop ] ] ] > ],
			   VAL [ SPR < >,
				 SUBJ < >,
				 COMPS < >,
				 SPEC < > ],
			   POSTHEAD + ],
		     CONT.HOOK [ LTOP #ltop ] ],
	     LKEYS.KEYREL.ARG1 #ind ],
    INFLECTED - ].

non-demonstrative-adj-lex := adjective-lex &
[ SYNSEM.LOCAL.CAT.HEAD.ADJECTIVE-TYPE non-demonstrative-adjective,
  SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [  MODORDER adj-modorder ] > ]]]],
  SYNSEM [ MODORDER adj-modorder ],
  SYNSEM.INFLECTED-FOR-NUMBER - ].

;;having the restriction that this be dem-modorder blocks definites and not having it allows two parses for def dems.
proximal-demonstrative-adj-lex := adjective-lex &
[ SYNSEM.LOCAL.CAT.HEAD.ADJECTIVE-TYPE demonstrative-adjective,
  SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [  MODORDER adj-modorder ] > ]]]],
  SYNSEM [ MODORDER dem-modorder ],
  SYNSEM.LKEYS.KEYREL.PRED proximal+dem_a_rel,
  SYNSEM.INFLECTED-FOR-NUMBER + ].

;;; 
hebrew-head-adj-int-phrase := head-adj-int-phrase &
[ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
  SYNSEM.MODORDER #modorder,
  NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [  MODORDER #modorder2 ] > ]]]],
  HEAD-DTR.SYNSEM.MODORDER #modorder2,
  NON-HEAD-DTR.SYNSEM.MODORDER #modorder ].

;;this eliminates an extra parse for negated transitive verbs
adj-head-scop-phrase :+ [ HEAD-DTR adj-head-follows ].

adj-head-follows := avm.
basic-head-opt-comp-phrase :+ adj-head-follows.
lex-rule :+ adj-head-follows.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 			VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

head :+ [ AUX bool,
    FORM form ] .

form := avm .
fin := form .
inf := form .
imp := form .

;; INFLECTED - prevents the lexicon items from playing in the syntax without undergoing some sort of an inflectional
;; rule, even one that doesn't add any inflection (infl-ltow-rule that assignes person, gender and number to the verb w/o
;; adding any inflection - that is 3rd, sing, masc).


verb-lex := basic-verb-lex & 
  [ INFLECTED -,
    SYNSEM.LOCAL [ CAT [ VAL [ SPR < >,
                             SPEC < >,
                             SUBJ < #subj > ],
			 HC-LIGHT -],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CAT.VAL [ SPR < >,
                                 COMPS < > ],
                       CONT.HOOK.INDEX #xarg ] ], ... > ] .

;;; If there are aspects of the syntax which pick out
;;; lexical Vs (transitive or intransitive) such as V-attachment
;;; of adverbs or argument composition auxiliaries which take V
;;; complements, we need to distinguish (intranstive) V and VP.
;;; To do so, we make use of a feature LIGHT.  Phrases are
;;; generally [LIGHT -] with the exception of head-complement
;;; phrases, which take their value for LIGHT from the head's
;;; HC-LIGHT feature.  To make this work for us here, constraint
;;; HC-LIGHT on verbs to be -.
;;  I moved this to the rule itself
;;  verb-lex :+ [ SYNSEM.LOCAL.CAT.HC-LIGHT - ] .

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;				CASE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; There was a decision to make regarding case. Do transitive verbs, such as "eat" take a PP or an accusative NP?
;; On the one hand the "at" in "h-klb awkl at h-ycm" (the dog is eating the bone) looks like a preposition. But then what about indefinite objects, such as
;; "h-klb awkl ycm" (the dog is eating a bone) which are completely unmarked? 
;; So we made "at" an accusative case marker
;; What about verbs like "chase", which in Hebrew are "chase after"? 
;; Is this another type of transitive that happens to take a PP? 
;; The preposition "after" has to appear in front of the object regardless of its definiteness.
;; To avoid confusion, I am considering as TRANSITIVE only those verbs that take unmarked indefinite NPs and definite
;; marked with "at"

;; There is no marking on nominatives
;; There are two cases then. Nominative which is not lexicalized and accusative which is lexicalized only with
;; definite NPs via the acc-case-marker-p-lex, namely "at". The rest of the "cases" are simply prepositions.

;; But until the morphology hookup is in place, we need some treatment for pronouns.
;; In texts, the preposition and the pronoun are combined into one word for most prepositions.
;; The morphological analyzer does tease the two morphemes apart.
;; Example: "axriw" (after him) is analyzed as (PP (prep axri) (pronoun hwa)) where "hwa" is the third person singular nominative personal pronoun
;; But until the morphology is in place, it is probably better to assign case directly to the surface form.
;; This will result in redundancy in terms of verb types (as in each case we will need a different treatment for pronouns and a different one for
;; other nouns, but once the morphology is in place we can simply get rid of one of the alternatives.

+np :+ [ CASE case ].
case := *top*.
nom := case.
sem-acc := case.
acc := sem-acc.
acc-axri := sem-acc.
dat := case.

;; 
; FORM value for object marking adpositions.

p-case := form.
p-acc := p-case.
p-dat := p-case.
p-at := p-acc.
p-acc-axri := p-acc .
p-dat-l := p-dat .

; Should p-acc-axri br p-case rather than p-acc?
; ?

;;; Case-marking adpositions
;;; Case marking adpositions are constrained not to
;;; be modifiers.

; This is the rule for all preps other than "at"
case-marker-p-lex := basic-one-arg & raise-sem-lex-item &
  [ SYNSEM.LOCAL.CAT [ HEAD adp &
                            [ MOD < > ],
                       VAL [ SPR < >,
                             SUBJ < >,
                             COMPS < #comps >,
                             SPEC < > ] ],
    ARG-ST < #comps & [ LOCAL.CAT [ HEAD noun &  [ CASE nom ] & 
					  [ PROPER_PRONOUN_COMMON not_personal_pronoun ], 
				     VAL.SPR < > ] ] > ].

; This rule is here just for "at"
acc-case-marker-p-lex := case-marker-p-lex &
 [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
   ARG-ST < #comps & [ LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act ] > ]. 

intransitive-verb-lex := verb-lex & intransitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS < >,
			   SUBJ < #subj > ],
    ARG-ST < #subj & synsem & [ LOCAL.CAT [ HEAD noun & [ CASE nom ], 
			   VAL.SPR <>] ] > ].

;; h-klb awkl ycm (the dog is eating a bone) 
;; h-klb awkl at h-ycm (the dog is eating the bone)
;; h-klb awkl awth (the dog is eating it/her)
;; HEAD +np on the complement allows accusative indefinite NPs, accusative pronoun NPs, 
;; and PPs with definite NP headed by "at", the accusative marker

transitive-verb-lex := verb-lex & transitive-lex-item &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb,
                    	 VAL [ SPR < >,
                               SUBJ < #subj >,
                               COMPS < #comps >,
                               SPEC < > ] ] ],
    ARG-ST < #subj & synsem & [ LOCAL.CAT [ HEAD noun & [ CASE nom ],
				            VAL.SPR <> ]] , 
             #comps & [ LOCAL.CAT [ HEAD +np & [ CASE acc ] & [ FORM p-at ],
				    VAL [ SPR <>, 
				          COMPS <> ] ] ] > ].


;; what are the consequences of pp-acc-verb-lex verb type inheriting from "transitive-lex-item"?
;; it just means that there are 2 arguments 
;; h-klb rwdf axri h-xtwl (the dog is chasing the cat)
;; h-klb rwdf axriw (the dog is chasing it/him)
;; The complement of this verb may be either an accusative pronoun NP or a PP with an accustaive NP

pp-acc-verb-lex := verb-lex & transitive-lex-item &
   [ SYNSEM.LOCAL [ CAT [ HEAD verb,
                    	 VAL [ SPR < >,
                               SUBJ < #subj >,
                               COMPS < #comps >,
                               SPEC < > ] ] ],
     ARG-ST < #subj & synsem & [ LOCAL.CAT [ HEAD noun & [ CASE nom ],
				            VAL.SPR <> ]] ,  
	       #comps & [ LOCAL.CAT [ HEAD +np & [ CASE sem-acc ] & [ FORM p-acc ],
				    VAL [ SPR <>, 
				          COMPS <> ] ] ] > ].

;;this is temporary fakery to handle pronouns versus pps
; h-klb rwdf axri h-xtwl (the dog is chasing the cat)
; 
with-pp-acc-verb-lex := pp-acc-verb-lex &
 [ ARG-ST < synsem,[ LOCAL.CAT.HEAD adp & [ FORM p-acc-axri ] ] > ].

;h-klb rwdf axriw (the dog is chasing it/him)
with-pronoun-object-verb-lex := pp-acc-verb-lex &
 [ ARG-ST < synsem,[ LOCAL.CAT.HEAD noun & [ CASE acc-axri,
                                             PROPER_PRONOUN_COMMON personal_pronoun ] ] > ].


;;;Sandy eats; Sandy eats cheese
transitive-with-optional-object-verb-lex := transitive-verb-lex &
[ SYNSEM.LOCAL.CAT.VAL.COMPS < [OPT-CS type-id] > ].

;;;Sandy loves Pat (though "Sandy loves" is OK too in some contexts)???
transitive-with-object-verb-lex := transitive-verb-lex &
[ SYNSEM.LOCAL.CAT.VAL.COMPS < [OPT -] > ].


clause-embedding-verb-lex := verb-lex & clausal-second-arg-trans-lex-item &
[ SYNSEM.LOCAL.CAT.VAL  [ SUBJ < #subj & synsem 
				      & [ LOCAL.CAT [ HEAD noun &
							   [ CASE nom ],
						      VAL.SPR <> ]] >,                          
			  COMPS < #comps & [ LOCAL.CAT.HEAD comp,
					     LOCAL.CAT.VAL.COMPS < >,
					     LOCAL.CAT.HEAD.COMPLEMENTIZER-TYPE embedded-complementizer ]> ],
  ARG-ST < #subj,#comps > ]. 

;;;two direct objects - Sandy taught Pat math
ditransitive-verb-lex := verb-lex & ditransitive-lex-item & 
[ SYNSEM.LOCAL [ CAT [ HEAD verb,
                    	 VAL [ SPR < >,
                               SUBJ < #subj & synsem 
				      & [ LOCAL.CAT [ HEAD noun &
							   [ CASE nom ],
						      VAL.SPR <> ]] >,
                               COMPS < #comps1
				       & [ LOCAL.CAT [ HEAD +np &
							    [ CASE sem-acc ],
						       VAL.SPR <>, 
						       VAL.COMPS <> ]], 
				       #comps2
				       & [ LOCAL.CAT [ HEAD +np &
							    [ CASE sem-acc ],
						       VAL.SPR <>, 
						       VAL.COMPS <> ]] >,
                               SPEC < > ]]],
    ARG-ST < #subj, #comps1, #comps2 > ].

;;do we need another one with the cases reversed?
;;;one direct object and one indirect object with "to" - Pat gave a book to Mary
dative-ditransitive-verb-lex := verb-lex & ditransitive-lex-item & 
[ SYNSEM.LOCAL [ CAT [ HEAD verb,
                    	 VAL [ SPR < >,
                               SUBJ < #subj & synsem 
				      & [ LOCAL.CAT [ HEAD noun &
							   [ CASE nom ],
						      VAL.SPR <> ]] >,
                               COMPS < #comps1
				       & [ LOCAL.CAT [ HEAD +np &
							    [ CASE sem-acc ],
						       VAL.SPR <>, 
						       VAL.COMPS <> ]], 
				       #comps2
				       & [ LOCAL.CAT [ HEAD +np &
							    [ CASE dat ],
						       VAL.SPR <>, 
						       VAL.COMPS <> ]] >,
                               SPEC < > ]]],
    ARG-ST < #subj, #comps1, #comps2 > ].

dative-transitive-with-optional-object-verb-lex := dative-transitive-verb-lex &
[ SYNSEM.LOCAL.CAT.VAL.COMPS < [OPT-CS type-id] > ].

dative-transitive-with-object-verb-lex := dative-transitive-verb-lex &
[ SYNSEM.LOCAL.CAT.VAL.COMPS < [OPT -] > ].

;;;object is expressed via pp - zh la mziq li, hwa ywzr li, hwa mrbic li, 
;;; what about hwa rwdp axri hklb? this is not dative
dative-transitive-verb-lex := basic-verb-lex & transitive-lex-item &
  [ 
    SYNSEM.LOCAL [ CAT [ HEAD verb,
                    	 VAL [ SPR < >,
                               SUBJ < #subj & synsem 
				      & [ LOCAL.CAT [ HEAD noun &
							   [ CASE nom ],
						      VAL.SPR <> ]] >,
                               COMPS < #comps 
				       & [ LOCAL.CAT [ HEAD +np &
							    [ CASE dat ],
						       VAL.SPR <>, 
						       VAL.COMPS <> ]] >,
                               SPEC < > ]]],
    ARG-ST < #subj, #comps > ].

;;;In addition, the KEYREL.ARG1 of the auxiliary should be identified with the CONT.HOOK.LTOP of the embedded verb.

raising-verb-with-infinitive-complement := verb-lex & trans-first-arg-raising-lex-item-1 &
[ 
  SYNSEM.LOCAL [ CAT [ HEAD verb & [FORM fin ],		       
		       VAL [ SUBJ < #subj & synsem & 
				    [ LOCAL.CAT [ HEAD noun &
						       [ CASE nom ],
						  VAL.SPR < > ]] >,	
			     COMPS < #comps &
				     [ LOCAL [ CAT [ HEAD verb & [ FORM inf ],
						   VAL.SUBJ < #subj >,
						   VAL.SPR < >,
						   VAL.SPEC < >,
						   VAL.COMPS < > ],
					       CONT.HOOK.LTOP #keyrel ]] >]]],
  SYNSEM.LKEYS.KEYREL.ARG1 #keyrel,
  ARG-ST < #subj, #comps > ].

interrogative-clause-embedding-verb-lex := clause-embedding-verb-lex &
[ SYNSEM.LOCAL.CAT.VAL  [ COMPS < [ LOCAL.CAT.HEAD.COMPLEMENTIZER-TYPE embedded-interrogative-complementizer ] > ] ].

declarative-clause-embedding-verb-lex := clause-embedding-verb-lex &
[ SYNSEM.LOCAL.CAT.VAL  [ COMPS < [ LOCAL.CAT.HEAD.COMPLEMENTIZER-TYPE embedded-declarative-complementizer ] > ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;     IMPERATIVE & Other stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cat :+ [ IMPERATIVE bool ].

imperative-construction-phrase := basic-head-opt-subj-phrase & imperative-clause &
[ SYNSEM.LOCAL.CAT.IMPERATIVE +,
  SYNSEM.LOCAL.CAT.MC +,
  HEAD-DTR.SYNSEM.LOCAL.CAT.IMPERATIVE -,
  HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
  HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF comm,
  HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM imp,
  HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG.PER second ] >,
  HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
  HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < >,
  HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
  SYNSEM.LOCAL.CAT.VAL.SPR < >,
  SYNSEM.LOCAL.CAT.VAL.SPEC < >,
  SYNSEM.LOCAL.CAT.VAL.COMPS < >].

;i think this is a feature for allowing unsaturated comps to continue playing
head-opt-follows := avm.
basic-head-opt-comp-phrase :+ head-opt-follows.
lexeme-to-word-rule :+ head-opt-follows.

basic-indef-head-opt-comp-phrase := basic-head-opt-comp-phrase &
[ HEAD-DTR head-opt-follows,
  C-CONT.RELS <! !> ].

;I realized that the issue with coordination of S in which one of the conjuncts has no overt subject is not
;that I need to enforce S coordination to conjoin only S's that are the same in terms of their subject's overtness
;or lack thereof, but that this is no good in the present tense. So I added a constraint that the verb has to be in the present tense
;for subject pro drop to occur. This is not strictly true, but a solution that takes into account all the subtleties is
;probably too complicated for this demo.
 
;non-imp-basic-head-opt-subj-phrase := basic-head-opt-subj-phrase &
non-imp-basic-head-opt-subj-phrase := decl-head-opt-subj-phrase &
 [ C-CONT.RELS <! !>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ OPT + ] >,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM fin,
   HEAD-DTR.SYNSEM.LOCAL.CAT.IMPERATIVE -,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-ques ].

;;this eliminates an extra parse for negated transitive verbs
adj-head-scop-phrase :+ [ HEAD-DTR adj-head-follows ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;			AGREEMENT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

png :+ [ PER person,
         NUM number,
         GEND gender,
         DEF-INDEF def-indef ]. 

person := *top*.
first := person.
second := person.
third := person.

number := *top*.
sg := number.
non-sg := number. ; use this one if your language only has sg-pl

gender := *top*.
masc := gender.
fem := gender.

def-indef := *top*.
def := def-indef.
indef := def-indef.

;;Adding types for some agreement inflectional aspects of nouns - this will go away when the grammar is hooked up to the morphological analyzer

masc-im-noun-lex := common-noun-lex &
 [ SYNSEM.LOCAL [ CAT.HEAD.NOUN-NON-SG-SUFFIX-TYPE im-suffix,
		  CONT.HOOK.INDEX.PNG [ GEND masc ] ] ].

fem-wt-noun-lex := common-noun-lex &
 [ SYNSEM.LOCAL [ CAT.HEAD.NOUN-NON-SG-SUFFIX-TYPE wt-suffix,
		  CONT.HOOK.INDEX.PNG [ GEND fem ] ] ].

masc-wt-noun-lex := common-noun-lex &
 [ SYNSEM.LOCAL [ CAT.HEAD.NOUN-NON-SG-SUFFIX-TYPE wt-suffix,
		  CONT.HOOK.INDEX.PNG [ GEND masc ] ] ].

fem-im-noun-lex := common-noun-lex &
 [ SYNSEM.LOCAL [ CAT.HEAD.NOUN-NON-SG-SUFFIX-TYPE im-suffix,
		  CONT.HOOK.INDEX.PNG [ GEND fem ] ] ].


;;Adding types for some inflectional aspects of verbs - this will go away when the grammar is hooked up to the morphological analyzer

verb-present-tense-f-sg-suffix-type-h := verb-lex & 
  [ SYNSEM.LOCAL.CAT.HEAD.VERB-PRESENT-TENSE-SG-F-SUFFIX-TYPE h-suffix ] .
verb-present-tense-f-sg-suffix-type-t := verb-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.VERB-PRESENT-TENSE-SG-F-SUFFIX-TYPE t-suffix ] .
h-intransitive-verb-lex := verb-present-tense-f-sg-suffix-type-h & intransitive-verb-lex .
t-intransitive-verb-lex := verb-present-tense-f-sg-suffix-type-t & intransitive-verb-lex .
h-transitive-verb-lex := verb-present-tense-f-sg-suffix-type-h & transitive-verb-lex .
t-transitive-verb-lex := verb-present-tense-f-sg-suffix-type-t & transitive-verb-lex .
h-with-pp-acc-verb-lex := verb-present-tense-f-sg-suffix-type-h & with-pp-acc-verb-lex .
t-with-pp-acc-verb-lex := verb-present-tense-f-sg-suffix-type-t & with-pp-acc-verb-lex .
h-with-pronoun-object-verb-lex := verb-present-tense-f-sg-suffix-type-h & with-pronoun-object-verb-lex .
t-with-pronoun-object-verb-lex := verb-present-tense-f-sg-suffix-type-t & with-pronoun-object-verb-lex .
t-clause-embedding-verb-lex := verb-present-tense-f-sg-suffix-type-t & clause-embedding-verb-lex .
t-interrogative-clause-embedding-verb-lex := verb-present-tense-f-sg-suffix-type-t & interrogative-clause-embedding-verb-lex .
t-declarative-clause-embedding-verb-lex := verb-present-tense-f-sg-suffix-type-t & declarative-clause-embedding-verb-lex .
h-declarative-clause-embedding-verb-lex := verb-present-tense-f-sg-suffix-type-h & declarative-clause-embedding-verb-lex .
h-interrogative-clause-embedding-verb-lex := verb-present-tense-f-sg-suffix-type-h & interrogative-clause-embedding-verb-lex .
h-raising-verb-with-infinitive-complement := verb-present-tense-f-sg-suffix-type-h & raising-verb-with-infinitive-complement .
h-dative-transitive-with-optional-object-verb-lex := verb-present-tense-f-sg-suffix-type-h & dative-transitive-with-optional-object-verb-lex .
;;;Lexical Rules for verbs & adjectives

+vj :+ [ VERB-PRESENT-TENSE-SG-F-SUFFIX-TYPE verb-suffix-type ].
verb-suffix-type := *top*.
t-suffix := verb-suffix-type.
h-suffix := verb-suffix-type.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;adverbs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;added second line here to prevent ambiguities but it doesn't really help much because it still allows too many
;what we want is the adv to modify only one type (v,vp or s). Right now it nodifies v anv vp
;head-adv-int-phrase := head-adj-int-phrase &
;[ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv ,
;  HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list ].

;so i guess the best is for now for it to modify vp only (they chase after cars quickly) - though v adv is OK too (they chase quickly after cars)
;so comps have to be empty
head-adv-int-phrase := head-adj-int-phrase &
[ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv ,
  HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
  HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>  ].

;adv-head-int-phrase := adj-head-int-phrase &
;[ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv, 
;  HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list ].

adverb-lex := basic-adverb-lex & intersective-mod-lex &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD verb ]>,
			   VAL [ SPR < >,
				 SUBJ < >,
				 COMPS < >,
				 SPEC < > ]]]]].

; Type for negative adverbs.

neg-adv-lex := basic-scopal-adverb-lex &
   [ SYNSEM.LOCAL.CAT [ POSTHEAD -,
			VAL [ SPR < >,
                              COMPS < >,
                              SUBJ < > ],
                        HEAD.MOD < [ LOCAL.CAT [ HEAD verb & [ FORM fin ] ],
                                 LIGHT + ] > ]].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;            INFLECTION RULES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

imperative-verb-inflection-rule := infl-ltow-rule &
 [ DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ FORM imp ] ] .

infinitival-verb-inflection-rule := infl-ltow-rule &
 [ DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ FORM inf ] ] .


present-tense-sg-f-t-verb-inflection-rule := infl-ltow-rule &
 [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [  OPT -,
                                  LOCAL.CONT.HOOK.INDEX.PNG [ GEND fem,
							     NUM sg ]] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ FORM fin, 
                                      VERB-PRESENT-TENSE-SG-F-SUFFIX-TYPE t-suffix] ].

present-tense-sg-f-h-verb-inflection-rule := infl-ltow-rule &
 [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ OPT -,
                                 LOCAL.CONT.HOOK.INDEX.PNG [ GEND fem,
							     NUM sg ]] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ FORM fin,
				      VERB-PRESENT-TENSE-SG-F-SUFFIX-TYPE h-suffix ] ].

present-tense-sg-m-verb-inflection-rule := const-ltow-rule &
 [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ OPT -,
                                 LOCAL.CONT.HOOK.INDEX.PNG [ GEND masc,
							     NUM sg ]] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ FORM fin ] ].

present-tense-non-sg-f-verb-inflection-rule := infl-ltow-rule &
 [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ OPT -,
                                 LOCAL.CONT.HOOK.INDEX.PNG [ GEND fem,
							     NUM non-sg ]] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ FORM fin ] ].

present-tense-non-sg-m-verb-inflection-rule := infl-ltow-rule &
 [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ OPT -,
                                 LOCAL.CONT.HOOK.INDEX.PNG [ GEND masc,
							     NUM non-sg ]] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ FORM fin ] ].

;;;lexeme-to-lexeme rules for NOUNs

noun :+ [ NOUN-NON-SG-SUFFIX-TYPE noun-suffix-type ].
noun-suffix-type := *top*.
im-wt-suffix-type := noun-suffix-type.
im-suffix := im-wt-suffix-type.
wt-suffix := im-wt-suffix-type.
no-suffix := noun-suffix-type.

;;;This results in about 12 parses because the output is compatible with other parts of speech, etc. the local.cat information is not copied at all
;;;noun-non-sg-im-suffix-rule := infl-ltol-rule &
;;; [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [NUM non-sg],
;;;   DTR.INFLECTED - ].

;;;This is not enough because the person & gender info is not copied 
;;;noun-non-sg-im-suffix-rule := infl-ltol-rule & same-cat-lex-rule &
;;;[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [NUM non-sg],
;;;  DTR.INFLECTED - ].

;;;we need this rule to just add something into the hook value
noun-non-sg-im-suffix-rule := infl-add-only-no-ccont-ltol-rule &
[ DTR lex-item,
  SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [NUM non-sg],
  SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON common,
  SYNSEM.LOCAL.CAT.HEAD noun,
  DTR.SYNSEM.LOCAL.CAT.HEAD.NOUN-NON-SG-SUFFIX-TYPE im-suffix,
  DTR.INFLECTED - ].

noun-non-sg-wt-suffix-rule := infl-add-only-no-ccont-ltol-rule &
[ DTR lex-item,
  SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [NUM non-sg],
  SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON common,
  SYNSEM.LOCAL.CAT.HEAD noun,
  SYNSEM.LOCAL.CAT.HEAD.NOUN-NON-SG-SUFFIX-TYPE wt-suffix,
  DTR.INFLECTED - ].

;;;this rule feeds itself - without this rule "spr hwlk" is accepted but so is "spr hwlkim"
;;;noun-sg-no-suffix-rule := const-add-only-ltol-rule & 

;;;this is OK
noun-sg-no-suffix-rule := const-head-change-only-ltol-rule &
[ DTR lex-item,
  SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [NUM sg],
  SYNSEM.LOCAL.CAT.HEAD.NOUN-NON-SG-SUFFIX-TYPE no-suffix,
  SYNSEM.INFLECTED-FOR-NUMBER +,
  SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON common,
  SYNSEM.LOCAL.CAT.HEAD noun,
  DTR.SYNSEM.INFLECTED-FOR-NUMBER -,
  DTR.SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON common,
  DTR.SYNSEM.LOCAL.CAT.HEAD noun,
  DTR.INFLECTED - ].

;;;Definitness
;;;All nouns and adjectives are marked for [inflected -]
;;;it is necessary to force this rule to apply to lexemes that have NUM already

synsem :+  [ INFLECTED-FOR-NUMBER bool].

def-h-noun-rule := infl-ltow-rule &
 [ SYNSEM [ MODORDER adj-modorder ],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ DEF-INDEF def ],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act ,
   SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON common,
   SYNSEM.LOCAL.CAT.HEAD.CASE nom,
   DTR.SYNSEM.LOCAL.CAT.HEAD noun,
   DTR.SYNSEM.INFLECTED-FOR-NUMBER + ].

indef-noun-rule := const-ltow-rule &
 [ SYNSEM [ MODORDER adj-modorder ],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ DEF-INDEF indef ],
   DTR.SYNSEM.LOCAL.CAT.HEAD noun,
   DTR.SYNSEM.INFLECTED-FOR-NUMBER + ].

def-proper-noun-rule := const-ltow-rule &
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act ,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ DEF-INDEF def ],
   SYNSEM.LOCAL.CAT.HEAD.CASE nom,
   SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON proper,
   DTR.SYNSEM.LOCAL.CAT.HEAD noun ].

def-pronoun-rule := const-ltow-rule &
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ COG-ST activ-or-more,
				  SPECI + ] ,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ DEF-INDEF def ],
   SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON personal_pronoun,
   DTR.SYNSEM.LOCAL.CAT.HEAD noun ].

indef-dem-pronoun-rule := const-ltow-rule &
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ COG-ST activ+fam,
				  SPECI + ],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ DEF-INDEF indef ],
   SYNSEM.LOCAL.CAT.HEAD.PROPER_PRONOUN_COMMON it_pronoun,
   DTR.SYNSEM.LOCAL.CAT.HEAD noun ].


;;; Adjective suffixes - suffixes are as in the present tense verbs  

sg-f-t-adjective-inflection-rule := infl-add-only-no-ccont-ltol-rule &
 [ DTR lex-item,
   DTR.SYNSEM.INFLECTED-FOR-NUMBER -,
   SYNSEM.INFLECTED-FOR-NUMBER +,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEND fem,
							     NUM sg ],
				 MODORDER #modorder_of_nom ] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD adj & 
				   [ VERB-PRESENT-TENSE-SG-F-SUFFIX-TYPE t-suffix,
				     ADJECTIVE-TYPE non-demonstrative-adjective ],
   DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ MODORDER #modorder_of_nom ] >,
   SYNSEM [ MODORDER #modorder_of_adj ], 
   DTR.SYNSEM [ MODORDER #modorder_of_adj ] ] .

sg-f-h-adjective-inflection-rule := infl-add-only-no-ccont-ltol-rule &
 [ DTR lex-item,
   DTR.SYNSEM.INFLECTED-FOR-NUMBER -,
   SYNSEM.INFLECTED-FOR-NUMBER +,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEND fem,
							     NUM sg ],
				 MODORDER #modorder_of_nom ] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD adj & 
			     [ VERB-PRESENT-TENSE-SG-F-SUFFIX-TYPE h-suffix,
			       ADJECTIVE-TYPE non-demonstrative-adjective ],
   DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ MODORDER #modorder_of_nom ] >,
   SYNSEM [ MODORDER #modorder_of_adj ], 
   DTR.SYNSEM [ MODORDER #modorder_of_adj ] ].

non-sg-f-adjective-inflection-rule := infl-add-only-no-ccont-ltol-rule &
 [ DTR lex-item,
   DTR.SYNSEM.INFLECTED-FOR-NUMBER -,
   SYNSEM.INFLECTED-FOR-NUMBER +,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEND fem,
							     NUM non-sg ],
				 MODORDER #modorder_of_nom ] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD adj & [ ADJECTIVE-TYPE non-demonstrative-adjective ],
   DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ MODORDER #modorder_of_nom ] >,
   SYNSEM [ MODORDER #modorder_of_adj ], 
   DTR.SYNSEM [ MODORDER #modorder_of_adj ] ].

non-sg-m-adjective-inflection-rule := infl-add-only-no-ccont-ltol-rule &
 [ DTR lex-item,
   DTR.SYNSEM.INFLECTED-FOR-NUMBER -,
   SYNSEM.INFLECTED-FOR-NUMBER +,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEND masc,
							     NUM non-sg ],
				 MODORDER #modorder_of_nom ] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD adj & [ ADJECTIVE-TYPE non-demonstrative-adjective ],
   DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ MODORDER #modorder_of_nom ] >,
   SYNSEM [ MODORDER #modorder_of_adj ], 
   DTR.SYNSEM [ MODORDER #modorder_of_adj ] ].

;sg-m-adjective-inflection-rule := infl-add-only-no-ccont-ltol-rule &
;CAT.VAL.SPR 1-list - needs to be copied


sg-m-adjective-inflection-rule := const-add-only-no-ccont-ltol-rule &
 [ DTR lex-item,
   INFLECTED -,
   DTR.SYNSEM.INFLECTED-FOR-NUMBER -,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEND masc,
							      NUM sg ],
				 MODORDER #modorder_of_nom ] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD adj & [ ADJECTIVE-TYPE non-demonstrative-adjective ],
   DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ MODORDER #modorder_of_nom ] >,
   SYNSEM [ MODORDER #modorder_of_adj ], 
   DTR.SYNSEM [ MODORDER #modorder_of_adj ] ].


;dem-adjective-inflection-rule := infl-add-only-no-ccont-ltol-rule &

dem-adjective-inflection-rule := const-add-only-no-ccont-ltol-rule &
 [ DTR lex-item,
   INFLECTED -,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG #png,
				 MODORDER #modorder_of_nom  ] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG #png,
                                     LOCAL.CONT.HOOK.INDEX.COG-ST activ+fam,
				      MODORDER #modorder_of_nom ] >,
   DTR.SYNSEM.LOCAL.CAT.HEAD adj  & [ ADJECTIVE-TYPE demonstrative-adjective ],
   SYNSEM [ MODORDER #modorder_of_adj ], 
   DTR.SYNSEM [ MODORDER #modorder_of_adj ] ].

;;;DTR infl-add-only-ltol-rule &
;;;      [ SYNSEM.LOCAL ... ]
;;; [ DTR lexeme-to-lexeme-rule &

adj :+ [ ADJECTIVE-TYPE adjective-type ].
adjective-type := *top*.
non-demonstrative-adjective := adjective-type.
demonstrative-adjective := adjective-type.

;;;ltol-or-lex-item := avm.
;;;lex-item :+ ltol-or-lex-item.
;;;lexeme-to-lexeme-rule :+ ltol-or-lex-item.

def-h-adj-rule := infl-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ DEF-INDEF def ] ] >,
    DTR lexeme-to-lexeme-rule,
    SYNSEM [ MODORDER #modorder_of_adj ], 
    DTR.SYNSEM [ MODORDER #modorder_of_adj ], 
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ MODORDER #modorder_of_nom,
				  LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act ] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD adj &
	[ MOD < [ MODORDER #modorder_of_nom ] > ] ].
		

indef-adj-rule := const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ DEF-INDEF indef ] ] >,
    DTR lexeme-to-lexeme-rule,
    SYNSEM [ MODORDER #modorder_of_adj ], 
    DTR.SYNSEM [ MODORDER #modorder_of_adj ], 
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ MODORDER #modorder_of_nom,
                                  LOCAL.CONT.HOOK.INDEX.COG-ST #cog-st ] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD adj & 
	[ MOD < [ MODORDER #modorder_of_nom,
                  LOCAL.CONT.HOOK.INDEX.COG-ST #cog-st ] > ] ].
		       

;;; ERB 2007-05-22 for mmt demo

present := tense.
past := tense.
future := tense.
