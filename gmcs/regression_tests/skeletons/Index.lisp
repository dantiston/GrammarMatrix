;;;
;;; this file should be `Index.lisp' and reside in the directory containing the
;;; tsdb(1) test suite skeleton databases (typically a subdirectory `skeletons'
;;; in the tsdb(1) database root directory `*tsdb-home*').
;;;
;;; the file should contain a single un-quote()d Common-Lisp list enumerating
;;; the available skeletons, e.g.
;;;
;;;   (((:path . "english") (:content . "English TSNLP test suite"))
;;;    ((:path . "csli") (:content . "CSLI (ERGO) test suite"))
;;;    ((:path . "vm") (:content . "English VerbMobil data")))
;;;
;;; where the individual entries are assoc() lists with at least two elements:
;;;
;;;   - :path --- the (relative) directory name containing the skeleton;
;;;   - :content --- a descriptive comment.
;;;
;;; the order of entries is irrelevant as the `tsdb :skeletons' command sorts
;;; the list lexicographically before output.
;;;

(
((:path . "tiniest") (:content . "tiniest: A very basic grammar just to get the regression tests started.  SOV word order, no frills."))
 ;;; new-regression-test-here
((:path . "cagr-pseudospanish-feature-resolution") (:content . "cagr-pseudospanish-feature-resolution: tests the part of coordination and agreement that creates feature resolution (using a grammar loosely based on Spanish)"))
((:path . "cagr-pseudo-closest-conjunct") (:content . "cagr-pseudo-closest-conjunct: tests the part of coordination and agreement that creates closest conjunct rules"))
((:path . "valchg-obj-add-post-np") (:content . "valchg-obj-add-post-np: object-adding valence change, new object added at end of comps"))
((:path . "valchg-obj-add-pre-np") (:content . "valchg-obj-add-pre-np: object-adding valence change, np added at front of comps"))
((:path . "valchg-subj-rem-obj-rem") (:content . "valchg-subj-rem-obj-rem: combining subject-removing and object-removing valence change"))
((:path . "valchg-subj-rem") (:content . "valchg-subj-rem: simple subject-removing valence change"))
((:path . "valchg-obj-rem") (:content . "valchg-obj-rem: simple object-removing valence change"))
((:path . "adj-adjn") (:content . "adj-adjn: Basic test for attributive adjectives."))
((:path . "infostr-foc-affix-subj-obj-hier") (:content . "infostr-foc-affix-subj-obj-hier: regression test for Yukaghir-like grammars"))
((:path . "adj-split-both+attr+pred") (:content . "adj-split-both+attr+pred: Test for adjectives where some adjectives are attributive only, some predicative only, and others can be both attributive and predicative."))
((:path . "adj-split-both+pred") (:content . "adj-split-both+pred: Test for adjectives where some adjectives are predicative only and others can be both attributive and predicative."))
((:path . "adj-split-both+attr") (:content . "adj-split-both+attr: Test for adjectives where some adjectives are attributive only and others can be both attributive and predicative."))
((:path . "adj-nadj") (:content . "adj-nadj: Basic test for attributive only adjectives modifying nouns before the adjective."))
((:path . "adj-either_adj_n") (:content . "adj-either_adj_n: Test for attributive adjective appearing prehead or posthead."))
((:path . "adj-n_adj_agr") (:content . "adj-n_adj_agr: Test for adjective agreement with posthead attributive adjectives."))
((:path . "adj-2adjn") (:content . "adj-2adjn: Test for two attributive adjectives modifying nouns in either posthead or prehead word orders."))
((:path . "adj-split_infl_cop_mix") (:content . "adj-split_infl_cop_mix: Test for predicative adjectives where some adjectives are copula complements and some are stative predicates, some of each appear with inflection, some of each without."))
((:path . "adj-split_infl_cop") (:content . "adj-split_infl_cop: Test for predicative adjectives where all predicative adjectives have event type inflection and some appear as copula complements."))
((:path . "adj-split_cop_stative_infl") (:content . "adj-split_cop_stative_infl: Test for predicative adjectives where some adjectives appear as copula complements with copula inflection and others as stative predicates with event type inflection."))
((:path . "adj-split_zero_adj_n_adj-infl") (:content . "adj-split_zero_adj_n_adj-infl: Test for predicative adjectives where all predicative adjectives as stative predicates and some require event type inflection."))
((:path . "adj-split_adj_zero_adj-infl_n") (:content . "adj-split_adj_zero_adj-infl_n: Test for predicative adjectives where all predicative adjectives as stative predicates and some require event type inflection."))
((:path . "adj-split_adj_cop_infl") (:content . "adj-split_adj_cop_infl: Test for predicative adjectives where some adjectives appear as copula complements and others as stative predicates with event type inflection."))
((:path . "adj-split_cop_adj_n_adj") (:content . "adj-split_cop_adj_n_adj: Test for predicative adjectives where some adjectives appear as copula complements and others as stative predicates."))
((:path . "adj-split_adj_cop_n_adj") (:content . "adj-split_adj_cop_n_adj: Test for predicative adjectives where some adjectives appear as copula complements and others as stative predicates."))
((:path . "adj-switching_infl_2") (:content . "adj-switching_infl_2: Test for stative predicate adjective with optional inflection in SA order."))
((:path . "adj-switching_infl_1") (:content . "adj-switching_infl_1: Test for stative predicate adjective with optional inflection in AS order."))
((:path . "adj-switching_infl_cop_infl") (:content . "adj-switching_infl_cop_infl: Test for switching predicative adjectives between copula with inflection and stative predicate with inflection."))
((:path . "adj-switching_infl_cop") (:content . "adj-switching_infl_cop: Test for switching predicative adjectives between copula and stative predicate with inflection."))
((:path . "adj-switching_cop") (:content . "adj-switching_cop: Test for optionally copula complement adjective."))
((:path . "adj-n_adj") (:content . "adj-n_adj: Test for stative predicate adjectives in SA word order."))
((:path . "adj-adj_n") (:content . "adj-adj_n: Test for stative predicate adjectives in AS word order."))
((:path . "adj-n_adj_subj_agr") (:content . "adj-n_adj_subj_agr: Test for stative predicate adjectives with subject agreement in SA word order."))
((:path . "adj-adj_n_subj_agr") (:content . "adj-adj_n_subj_agr: Test for stative predicate adjectives with subject agreement in AS word order."))
((:path . "adj-n_adj_infl") (:content . "adj-n_adj_infl: Test for stative predicate adjectives with inflection features in SA word order."))
((:path . "adj-adj_n_infl") (:content . "adj-adj_n_infl: Test for stative predicate adjectives with inflection features in AS word order."))
((:path . "adj-cop_adj_agr") (:content . "adj-cop_adj_agr: Test for adjective agreeing with subject in copula complement constructions."))
((:path . "adj-infl-subj_post_cop") (:content . "adj-infl-subj_post_cop: Test for adjectives that only agree with their subjects, appear as copula complements, and are post-head modifiers."))
((:path . "adj-infl-subj_pre_cop") (:content . "adj-infl-subj_pre_cop: Test for adjectives that only agree with their subjects, appear as copula complements, and are pre-head modifiers."))
((:path . "adj-infl-subj_post_stative") (:content . "adj-infl-subj_post_stative: Test for adjectives that only agree with their subjects, appear as stative predicates, and are post-head modifiers."))
((:path . "adj-infl-subj_pre_stative") (:content . "adj-infl-subj_pre_stative: Test for adjectives that only agree with their subjects, appear as stative predicates, and are pre-head modifiers."))
((:path . "adj-infl-mod_post_cop") (:content . "adj-infl-mod_post_cop: Test for adjectives that only agree with their modificands, appear as copula complements, and are post-head modifiers."))
((:path . "adj-infl-mod_pre_cop") (:content . "adj-infl-mod_pre_cop: Test for adjectives that only agree with their modificands, appear as copula complements, and are pre-head modifiers."))
((:path . "adj-infl-mod_post_stative") (:content . "adj-infl-mod_post_stative: Test for adjectives that only agree with their modificands, appear as stative predicates, and are post-head modifiers."))
((:path . "adj-infl-mod_pre_stative") (:content . "adj-infl-mod_pre_stative: Test for adjectives that only agree with their modificands, appear as stative predicates, and are pre-head modifiers."))
((:path . "adj-adj-agr-n") (:content . "adj-adj-agr-n: Test for adjective incorporation with one prefix position class with daughter agreement."))
((:path . "adj-2n-adj") (:content . "adj-2n-adj: Test for adjective incorporation with two suffix position classes."))
((:path . "adj-2adj-n") (:content . "adj-2adj-n: Test for adjective incorporation with two prefix position classes."))
((:path . "adj-adj_n_agr") (:content . "adj-adj_n_agr: Test for adjective agreement with prehead attributive adjectives."))
((:path . "adj-adj-n-adj") (:content . "adj-adj-n-adj: Test for adjective incorporation with one prefix position class and one suffix position class."))
((:path . "adj-split_cop") (:content . "adj-split_cop: Test for split copulas where different copulas take different complement sets."))
((:path . "adj-cop_agr_adj_agr_2") (:content . "adj-cop_agr_adj_agr_2: Test for copula and complement agreeing with each other and subject."))
((:path . "adj-cop_agr_adj_agr_1") (:content . "adj-cop_agr_adj_agr_1: Test for copula and complement agreeing with each other and subject."))
((:path . "adj-cop_infl_adj_agr") (:content . "adj-cop_infl_adj_agr: Test for copula inflection with copula complement agreeing with subject."))
((:path . "adj-cop_infl") (:content . "adj-cop_infl: Test for copula inflection."))
((:path . "adj-cop_agr") (:content . "adj-cop_agr: Test for copula agreement with subject."))
((:path . "adj-cop_comp") (:content . "adj-cop_comp: Basic test for copula before its complement."))
((:path . "adj-comp_cop") (:content . "adj-comp_cop: Basic test for copula after its complement."))
((:path . "adj-both-pre-cop") (:content . "adj-both-pre-cop: Test for adjectives that is a pre-head attributive modifier and can appear as a copula complement."))
((:path . "adj-both-pre-stative") (:content . "adj-both-pre-stative: Test for adjectives that is a pre-head attributive modifier and can appear as a stative predicate."))
((:path . "adj-both-post-stative") (:content . "adj-both-post-stative: Test for adjectives that is a post-head attributive modifier and can appear as a stative predicate."))
((:path . "adj-both-post-cop") (:content . "adj-both-post-cop: Test for adjectives that is a post-head attributive modifier and can appear as a copula complement."))
((:path . "adj-both-either-stative") (:content . "adj-both-either-stative: Test for adjectives that can be either be a pre-head or post-head attributive modifier and can appear as a stative predicate."))
((:path . "adj-both-either-cop") (:content . "adj-both-either-cop: Test for adjectives that can be either be a pre-head or post-head attributive modifier and can appear as a copula complement."))
((:path . "adj-both-either-cop") (:content . "adj-both-either-cop: "))
((:path . "adj-vso") (:content . "adj-vso: Test for attributive adjectives modifying nouns in a language with VSO word order."))
((:path . "adj-vos") (:content . "adj-vos: Test for attributive adjectives modifying nouns in a language with VOS word order."))
((:path . "adj-sov") (:content . "adj-sov: Test for attributive adjectives modifying nouns in a language with SOV word order."))
((:path . "adj-osv") (:content . "adj-osv: Test for attributive adjectives modifying nouns in a language with OSV word order."))
((:path . "adj-ovs") (:content . "adj-ovs: Test for attributive adjectives modifying nouns in a language with OVS word order."))
((:path . "adj-adjn") (:content . "adj-adjn: Basic test for attributive only adjectives modifying nouns after the adjective."))
((:path . "adj-1n-adj") (:content . "adj-1n-adj: Test for adjective incorporation with one suffix position class."))
((:path . "adj-1adj-n") (:content . "adj-1adj-n: Test for adjective incorporation with one prefix position class."))
((:path . "adj-1adjn") (:content . "adj-1adjn: Test for adjectives being the only modifier of their modificand."))
((:path . "adj-1adjn") (:content . "adj-1adjn: Test for adjectives being the only modifier of their modificand."))
((:path . "adj-1n-adj") (:content . "adj-1n-adj: Test for adjective incorporation with one suffix position class."))
((:path . "adj-1adj-n") (:content . "adj-1adj-n: Test for adjective incorporation with one prefix position class."))
((:path . "adj-1adjn") (:content . "adj-1adjn: Test for adjectives being the only modifier of their modificand."))
((:path . "adj-adjn") (:content . "adj-adjn: Basic test for attributive only adjectives modifying nouns after the adjective."))
((:path . "infostr-top-mod-after-noun") (:content . "infostr-top-mod-after-noun: infostr"))
((:path . "infostr-foc-vso-prev") (:content . "infostr-foc-vso-prev: infostr"))
((:path . "infostr-foc-vso-postv") (:content . "infostr-foc-vso-postv: infostr"))
((:path . "infostr-foc-vso-initial") (:content . "infostr-foc-vso-initial: infostr"))
((:path . "infostr-foc-vso-final") (:content . "infostr-foc-vso-final: infostr"))
((:path . "infostr-foc-vos-prev") (:content . "infostr-foc-vos-prev: infostr"))
((:path . "infostr-foc-vos-postv") (:content . "infostr-foc-vos-postv: infostr"))
((:path . "infostr-foc-vos-initial") (:content . "infostr-foc-vos-initial: infostr"))
((:path . "infostr-foc-vos-final") (:content . "infostr-foc-vos-final: infostr"))
((:path . "infostr-foc-vi-postv") (:content . "infostr-foc-vi-postv: infostr"))
((:path . "infostr-foc-vi-final") (:content . "infostr-foc-vi-final: infostr"))
((:path . "infostr-foc-vf-prev") (:content . "infostr-foc-vf-prev: infostr"))
((:path . "infostr-foc-vf-initial") (:content . "infostr-foc-vf-initial: infostr"))
((:path . "infostr-foc-v2-prev") (:content . "infostr-foc-v2-prev: infostr"))
((:path . "infostr-foc-v2-postv") (:content . "infostr-foc-v2-postv: infostr"))
((:path . "infostr-foc-v2-initial") (:content . "infostr-foc-v2-initial: infostr"))
((:path . "infostr-foc-v2-final") (:content . "infostr-foc-v2-final: infostr"))
((:path . "infostr-foc-svo-prev") (:content . "infostr-foc-svo-prev: infostr"))
((:path . "infostr-foc-svo-postv") (:content . "infostr-foc-svo-postv: infostr"))
((:path . "infostr-foc-svo-initial") (:content . "infostr-foc-svo-initial: infostr"))
((:path . "infostr-foc-svo-final") (:content . "infostr-foc-svo-final: infostr"))
((:path . "infostr-foc-sov-prev") (:content . "infostr-foc-sov-prev: infostr"))
((:path . "infostr-foc-sov-postv") (:content . "infostr-foc-sov-postv: infostr"))
((:path . "infostr-foc-sov-initial") (:content . "infostr-foc-sov-initial: infostr"))
((:path . "infostr-foc-sov-final") (:content . "infostr-foc-sov-final: infostr"))
((:path . "infostr-foc-ovs-prev") (:content . "infostr-foc-ovs-prev: infostr"))
((:path . "infostr-foc-ovs-postv") (:content . "infostr-foc-ovs-postv: infostr"))
((:path . "infostr-foc-ovs-initial") (:content . "infostr-foc-ovs-initial: infostr"))
((:path . "infostr-foc-ovs-final") (:content . "infostr-foc-ovs-final: infostr"))
((:path . "infostr-foc-osv-prev") (:content . "infostr-foc-osv-prev: infostr"))
((:path . "infostr-foc-osv-postv") (:content . "infostr-foc-osv-postv: infostr"))
((:path . "infostr-foc-osv-initial") (:content . "infostr-foc-osv-initial: infostr"))
((:path . "infostr-foc-osv-final") (:content . "infostr-foc-osv-final: infostr"))
((:path . "infostr-foc-mod-both-noun") (:content . "infostr-foc-mod-both-noun: infostr"))
((:path . "infostr-foc-mod-both-both") (:content . "infostr-foc-mod-both-both: infostr"))
((:path . "infostr-foc-mod-before-noun") (:content . "infostr-foc-mod-before-noun: infostr"))
((:path . "infostr-foc-mod-after-verb") (:content . "infostr-foc-mod-after-verb: infostr"))
((:path . "infostr-foc-mod-after-noun") (:content . "infostr-foc-mod-after-noun: \infostr"))
((:path . "infostr-foc-mod-after-both") (:content . "infostr-foc-mod-after-both: infostr"))
((:path . "infostr-foc-initial-topic-first") (:content . "infostr-foc-initial-topic-first: infostr"))
((:path . "infostr-foc-final-topic-first-cf-prev") (:content . "infostr-foc-final-topic-first-cf-prev: infostr"))
((:path . "infostr-foc-affix-subj-verb") (:content . "infostr-foc-affix-subj-verb: infostr"))
((:path . "infostr-foc-affix-subj-obj-verb") (:content . "infostr-foc-affix-subj-obj-verb: infostr"))
((:path . "infostr-foc-affix-subj-obj") (:content . "infostr-foc-affix-subj-obj: infostr"))
((:path . "infostr-foc-affix-subj") (:content . "infostr-foc-affix-subj: infostr"))
((:path . "infostr-foc-affix-obj-verb") (:content . "infostr-foc-affix-obj-verb: infostr"))
((:path . "infostr-foc-affix-obj") (:content . "infostr-foc-affix-obj: infostr"))
((:path . "infostr-foc-affix-after-noun") (:content . "infostr-foc-affix-after-noun: infostr"))
((:path . "infostr-foc-adp-after-noun") (:content . "infostr-foc-adp-after-noun: infostr"))
((:path . "infostr-ct-mod-after-noun") (:content . "infostr-ct-mod-after-noun: infostr"))
((:path . "infostr-cf-mod-after-noun") (:content . "infostr-cf-mod-after-noun: infostr"))
((:path . "neg-mod-mod") (:content . "neg-mod-mod: bipartite negation, two negative modifiers in mutual requires relationship"))
((:path . "neg-comp-mod") (:content . "neg-comp-mod: bipartite negation, negative complement carries semantics, requires a negative (dummy) modifier via NEG-SAT feature passing"))
((:path . "neg-comp-comp") (:content . "neg-comp-comp: two negative complements, introduced by two lexical rules, one attaches to aux, the other to lexical vers, mutual requires"))
((:path . "neg-head-mod-vpaux-modafter") (:content . "neg-head-mod-vpaux-modafter: bipartite neg, neg auxiliary requires dummy neg modifier, aux selects vp comp, mod after comp"))
((:path . "neg-head-comp-vpauxbefore-compbefore") (:content . "neg-head-comp-vpauxbefore-compbefore: bipartite neg, negaux selects dummy negcomp followed by vpcomp, raises subject"))
((:path . "neg-head-comp-vpauxbefore-compafter") (:content . "neg-head-comp-vpauxbefore-compafter: bibpartite neg, negaux selects vp complement (raises subject) second comp is dummy auxiliary negcomp"))
((:path . "neg-head-comp-sauxbefore-compbefore") (:content . "neg-head-comp-sauxbefore-compbefore: bipartite neg, negaux selects for dummy negcomp followed by s comp"))
((:path . "neg-head-comp-sauxbefore-compafter") (:content . "neg-head-comp-sauxbefore-compafter: bipartite neg, negaux selects for sentential complement followed by dummy negcomp"))
((:path . "neg-head-comp") (:content . "neg-head-comp: bipartite negation, negative auxiliary precedes S complement, requires dummy adv after S complement"))
((:path . "neg-infl-mod") (:content . "neg-infl-mod: bipartite negation, infl rule introduces feature dependency to require neg adv, uses mod rules"))
((:path . "neg-infl-comp") (:content . "neg-infl-comp: bipartite negation, infl lex-rule puts neg-comp on comps list of verb, a la French [fra]"))
((:path . "neg-infl-head") (:content . "neg-infl-head: bipartite negation neg-aux and required inflection on main verb"))
((:path . "neg-infl-infl") (:content . "neg-infl-infl: bipartite negation both bound, one to auxiliary the other to lexical verb"))
((:path . "neg-mod-vp-either") (:content . "neg-mod-vp-either: negative modifier which can occur on either side of the vp"))
((:path . "neg-v-attach-freewo") (:content . "neg-v-attach-freewo: ensures that lexical attachment for neg adverbs still works without problems with free word order"))
((:path . "multi-wd-lex") (:content . "multi-wd-lex: tests multi word lexical item output on a noun"))
((:path . "char-test-keep-list") (:content . "char-test-keep-list: test of repp preprocessing where we discard all punc not on a list submitted by user"))
((:path . "char-test-discard-all") (:content . "char-test-discard-all: test of repp preprocessing where we split on then discard all lower ascii punctuation including space and tab"))
((:path . "char-test-keep-list") (:content . "char-test-keep-list: test of repp preprocessing where user specifies a specific split-list along with default split on whitespace"))
((:path . "char-test-keep-all") (:content . "char-test-keep-all: test of repp preprocessing where user only wants to split on whitespace"))
((:path . "char-test-discard-all") (:content . "char-test-discard-all: tests string splitting and discarding on a list of default punctuation chars crammed b/t a noun and ve"))
((:path . "neg1b-neg2fd") (:content . "neg1b-neg2fd: bipartite negation, neg1 is bound and requires neg2, a posthead VP adverb, neg2 cannot occur without neg1"))
((:path . "neg1b-neg2fh") (:content . "neg1b-neg2fh: bipartite negation, neg1 is bound and requires neg2, a posthead VP adverb, neg2 cannot occur without neg1"))
((:path . "neg-comp-auxattach-postcomps") (:content . "neg-comp-auxattach-postcomps: negative complement adds a second "))
((:path . "neg-comp-finattach-precomps") (:content . "neg-comp-finattach-precomps: neg-comp-add-lex-rule adds neg-adv as selected first comp of a finite verb"))
((:path . "neg-comp-vattach-precomps") (:content . "neg-comp-vattach-precomps: negative adverb as selected complement of non-auxiliary verb"))
((:path . "neg-comp-auxattach-precomps") (:content . "neg-comp-auxattach-precomps: neg adv as selected first comp of an aux type after application of a lexical rule"))
((:path . "neg-infl-mini") (:content . "neg-infl-mini: negation as inflection, simple case"))
((:path . "neg-infl-sole-suffix") (:content . "neg-infl-sole-suffix: negation as the only suffix, optional"))
((:path . "neg-adv-vp-pre") (:content . "neg-adv-vp-pre: negation as independent pre VP modifier"))
((:path . "neg-infl-final-opt-suffix") (:content . "neg-infl-final-opt-suffix: Negative affix as optional suffix at end of suffix string"))
((:path . "neg-infl-nonfinal-suffix") (:content . "neg-infl-nonfinal-suffix: Inflectional negation as optional non-final suffix, optionality with check box"))
((:path . "neg-head-feature") (:content . "neg-head-feature: uses a syntactic head feature to ensure that two affixes are mutually incompatible---intended to model the incompatibility of negation with certain other inflectional morphemes; implemented by having those morphemes specify NEGATED -, while negation obviously, has NEGATION +."))
((:path . "neg-zero-min") (:content . "neg-zero-min: checks semantics of negation for a basic zero-neg grammar (a phonologically empty negation suffix)"))
((:path . "neg-aux-min") (:content . "neg-aux-min: scope of negation for negative auxiliary verbs. uses minimal grammar augmented with some choices for auxiliaries"))
((:path . "bipartite-stems") (:content . "bipartite-stems: Basic test cases for bipartite stems, based on mini-English"))
((:path . "morphotactics-impl-expl-disjunction") (:content . "morphotactics-impl-expl-disjunction: Models and tests both implicit and explicit non-sequential disjunctions, and an explicit sequential disjunction."))
((:path . "morphotactics-lrt-inputs") (:content . "morphotactics-lrt-inputs: Tests inputs and constraints using hierarchies (trees and multiple inheritance) of lexical rule types."))
((:path . "morphotactics-req-fbd") (:content . "morphotactics-req-fbd: Tests forwards and backwards require, and (backward) forbid, morphotactic co-occurrence restrictions on an input graph with both conjunction and disjunction."))
((:path . "morphotactics-opt-oblig-single-input") (:content . "morphotactics-opt-oblig-single-input: Tests simple morphotactics with position classes having only 1 input. Also tests that obligatory PCs arequired by the lexical types they take as input."))
((:path . "mood-buildhierarchy") (:content . "mood-buildhierarchy: testing the build your own mood hierarchy"))
((:path . "asp-mood-contrast-options") (:content . "asp-mood-contrast-options: tests options to add simple imper/perf and subj/ind hierarchies"))
((:path . "subj-v-inv-obj-drop") (:content . "subj-v-inv-obj-drop: Testing interaction of subj-v inversion and object drop, as well as interaction of subj-v intersion and FORM and AUX features."))
((:path . "eng-qpart-inf") (:content . "eng-qpart-inf: Testing interaction of non-finite form and question particle.  Question particle should now only attach to finite sentences."))
((:path . "arg-opt-lex-comps-drop-np-wth-drop-np-wthout") (:content . "arg-opt-lex-comps-drop-np-wth-drop-np-wthout: slexically based complement dropping.  marker is not permitted for dropped or overt objects"))
((:path . "arg-opt-lex-subj-drop-marker-req-wth-drop-opt-wthout") (:content . "arg-opt-lex-subj-drop-marker-req-wth-drop-opt-wthout: lexically based subject dropping. marker is required for a dropped subject and optinal for a overt subject"))
((:path . "arg-opt-lex-subj-drop-marker-req-wth-drop-np-wthout") (:content . "arg-opt-lex-subj-drop-marker-req-wth-drop-np-wthout: lexically based subject dropping. mmareker is required with a dropped subject and not permitted with an overt subject"))
((:path . "arg-opt-lex-subj-drop-marker-opt-wth-drop-req-wthout") (:content . "arg-opt-lex-subj-drop-marker-opt-wth-drop-req-wthout: lexically based subject dropping. marker is required with a dropped subject and required with an overt subject"))
((:path . "arg-opt-lex-subj-drop-marker-opt-wth-drop-opt-wthout") (:content . "arg-opt-lex-subj-drop-marker-opt-wth-drop-opt-wthout: lexically based subject drop. marker is optional witha dropped subject and optiona l with an overt subject"))
((:path . "arg-opt-lex-subj-drop-marker-opt-wth-drop-np-wthout") (:content . "arg-opt-lex-subj-drop-marker-opt-wth-drop-np-wthout: lexically based subject dropping. maker is optional with drop and onot permitted with overt subject"))
((:path . "arg-opt-lex-subj-drop-marker-np-wth-drop-req-wthout") (:content . "arg-opt-lex-subj-drop-marker-np-wth-drop-req-wthout: lexically based subject dropping. subject marker is re not permitted with an dropped subject and required with an overt subject."))
((:path . "arg-opt-lex-subj-drop-marker-np-wth-drop-opt-wthout") (:content . "arg-opt-lex-subj-drop-marker-np-wth-drop-opt-wthout: subject dropping.lexically based. marker is not permitted when subject is dropped and is optional when it is overt"))
((:path . "arg-opt-lex-comps-drop-marker-req-wth-drop-req-wthout") (:content . "arg-opt-lex-comps-drop-marker-req-wth-drop-req-wthout: marker is required with a dropped object and required with an overt object. lexically based."))
((:path . "arg-opt-lex-comps-drop-marker-req-wth-drop-opt-wthout") (:content . "arg-opt-lex-comps-drop-marker-req-wth-drop-opt-wthout: marker is required with an ovdropped object and optional with an overt object. lexically based"))
((:path . "arg-opt-lex-comps-drop-marker-req-wth-drop-np-wthout") (:content . "arg-opt-lex-comps-drop-marker-req-wth-drop-np-wthout: marker is required wihen an object is dropped and not permitted with an overt object. lexically based"))
((:path . "arg-opt-lex-comps-drop-marker-opt-wth-drop-req-wthout") (:content . "arg-opt-lex-comps-drop-marker-opt-wth-drop-req-wthout: marker is optional with a dropped object and required with an overt object. lecixically based"))
((:path . "arg-opt-lex-comps-drop-marker-opt-wth-drop-opt-wthout") (:content . "arg-opt-lex-comps-drop-marker-opt-wth-drop-opt-wthout: marker is optional for both dropped and overt objects.  lexically based"))
((:path . "arg-opt-lex-comps-drop-marker-opt-wth-drop-np-wthout") (:content . "arg-opt-lex-comps-drop-marker-opt-wth-drop-np-wthout: markerop optional with dropped object and not permitted with overt object. lexically based"))
((:path . "arg-opt-lex-comps-drop-marker-np-wth-drop-req-wthout") (:content . "arg-opt-lex-comps-drop-marker-np-wth-drop-req-wthout: Marker not permitted with dropped object and required with an overt object. Lexically based."))
((:path . "arg-opt-lex-comps-drop-marker-np-wth-drop-opt-wthout") (:content . "arg-opt-lex-comps-drop-marker-np-wth-drop-opt-wthout: Markers are not permitted if the object is dropped and optional if it is overt.  Lexically Ba[D[D[A[D"))
((:path . "infl-q-nonfinal-suffix") (:content . "infl-q-nonfinal-suffix: Question affix as non-final in suffix string."))
((:path . "infl-q-final-opt-suffix") (:content . "infl-q-final-opt-suffix: Question inflection as optional suffix after one other suffix"))
((:path . "infl-q-aux-verb") (:content . "infl-q-aux-verb: Questions as inflection on aux verbs."))
((:path . "infl-q-main-verb-prefix") (:content . "infl-q-main-verb-prefix: Questions as prefix on main verbs."))
((:path . "infl-q-main-verb") (:content . "infl-q-main-verb: Question marking as inflection on the main verb, no other affixes"))
((:path . "subj-aux-inv-q") (:content . "subj-aux-inv-q: Questions marked by subj-aux inversion."))
((:path . "qpart-yes-no") (:content . "qpart-yes-no: Questions marked via sentence-initial question particle."))
((:path . "infl-neg-sole-suffix") (:content . "infl-neg-sole-suffix: Negation as the only suffix, optional"))
((:path . "infl-neg-nonfinal-suffix") (:content . "infl-neg-nonfinal-suffix: Inflectional negation as optional non-final suffix, optionality with check box"))
((:path . "infl-neg-final-opt-suffix") (:content . "infl-neg-final-opt-suffix: Negative affix as optional suffix at end of suffix string"))
((:path . "Sahaptin-short") (:content . "Sahaptin-short: Sahaptin, shorter version (sfd dissertation)"))
((:path . "Sahaptin") (:content . "Sahaptin: Sahaptin (sfd dissertation)"))
((:path . "case-mixed2") (:content . "case-mixed2: mixed adpositional and morphological marking (2)"))
((:path . "Tagalog") (:content . "Tagalog: Tagalog (sfd dissertation)"))
((:path . "Hindi") (:content . "Hindi: Hindi (sfd dissertation)"))
((:path . "German") (:content . "German: German (sfd dissertation)"))
((:path . "Fore") (:content . "Fore: Fore (sfd dissertation)"))
((:path . "Dyirbal") (:content . "Dyirbal: Dyirbal (sfd dissertation)"))
((:path . "Cree") (:content . "Cree: Plains Cree (sfd dissertation)"))
((:path . "arg-opt-lex-cntxt-2feat-subj-drop-marker-req-wth-drop-req-wthout") (:content . "arg-opt-lex-cntxt-2feat-subj-drop-marker-req-wth-drop-req-wthout: Subject dropping only in one context with multiple features.  One specified on the verb.  One on the subj."))
((:path . "arg-opt-lex-cntxt-subj-drop-marker-req-wth-drop-req-wthout") (:content . "arg-opt-lex-cntxt-subj-drop-marker-req-wth-drop-req-wthout: Subject dropping according to one context with one feature specified on the verb."))
((:path . "arg-opt-lex-subj-drop-marker-req-wth-drop-req-wthout") (:content . "arg-opt-lex-subj-drop-marker-req-wth-drop-req-wthout: Lexically based subject dropping. Marker required for dropped and overt subjs."))
((:path . "arg-opt-lex-subj-drop-no-marker") (:content . "arg-opt-lex-subj-drop-no-marker: Lexical based subject dropping. No marker."))
((:path . "arg-opt-all-subj-drop-marker-req-wth-drop-req-wthout") (:content . "arg-opt-all-subj-drop-marker-req-wth-drop-req-wthout: Subject dropping for all verb types. Marker required for both dropped and overt subjects"))
((:path . "arg-opt-all-subj-drop-marker-req-wth-drop-opt-wthout") (:content . "arg-opt-all-subj-drop-marker-req-wth-drop-opt-wthout: Subject dropping allowed for all verb types.  Marker req for drop and opt for overt subj."))
((:path . "arg-opt-all-subj-drop-marker-req-wth-drop-np-wthout") (:content . "arg-opt-all-subj-drop-marker-req-wth-drop-np-wthout: Subject dropping allowed for all verb types. Marker required for drop and not permitted with overt subj."))
((:path . "arg-opt-all-subj-drop-marker-opt-wth-drop-req-wthout") (:content . "arg-opt-all-subj-drop-marker-opt-wth-drop-req-wthout: Subject dropping allowed for all verb types. Marker opt for dropped subj and req for overt subj."))
((:path . "arg-opt-all-subj-drop-marker-opt-wth-drop-opt-wthout") (:content . "arg-opt-all-subj-drop-marker-opt-wth-drop-opt-wthout: Subject dropping allowed for al verb types. Marker optional for both dropped and overt subjects."))
((:path . "arg-opt-all-subj-drop-marker-opt-wth-drop-np-wthout") (:content . "arg-opt-all-subj-drop-marker-opt-wth-drop-np-wthout: Subject dropping for all verb types. Marker optional with drop and not permitted with overt subj."))
((:path . "arg-opt-all-subj-drop-marker-np-wth-drop-req-wthout") (:content . "arg-opt-all-subj-drop-marker-np-wth-drop-req-wthout: Subject dropping for all verb types. Marker not permitted with dropped subj and req with overt arg."))
((:path . "arg-opt-all-subj-drop-marker-np-wth-drop-opt-wthout") (:content . "arg-opt-all-subj-drop-marker-np-wth-drop-opt-wthout: Subject dropping is allowed for all verb types.  A marker is not permitted with a dropped subject and is optional with an overt one.  Object dropping is not allowed."))
((:path . "arg-opt-all-comps-drop-marker-opt-wth-drop-req-wthout") (:content . "Object dropping for all verb types.  Marker is optional for dropped objects and required for overt objects."))
((:path . "arg-opt-all-comps-drop-marker-np-wth-drop-opt-wthout") (:content . "Object dropping is allowed for all verb types. A marker is not permitted with dropped arguments and is optional for overt."))
((:path . "arg-opt-all-comps-drop-marker-np-wth-drop-req-wthout") (:content . "Object dropping is allowed for all verb types.  A marker is required with overt arguments and not permitted with dropped arguments."))
((:path . "arg-opt-all-comps-drop-marker-opt-wth-drop-np-wthout") (:content . "Object dropping is allowed for all verb types and a marker is optional if the object is dropped and not permitted if it is overt."))
((:path . "arg-opt-all-comps-drop-marker-opt-wth-drop-opt-wthout") (:content . "Object dropping is allowed for verb types and object marking is optional when for dropped and overt objects."))
((:path . "arg-opt-all-comps-drop-marker-req-wth-drop-np-wthout") (:content . "Object dropping is allowed for all verbs and an object marker is required when the object is dropped and not permitted with an overt object."))
((:path . "arg-opt-all-comps-drop-marker-req-wth-drop-req-wthout") (:content . "Object dropping is allowed for all verbs and a marker is required when objects are dropped and when they are not."))
((:path . "arg-opt-all-comps-drop-marker-req-wth-drop-opt-wthout") (:content . "Object dropping allowed for all verbs.  Marker is required for dropping and optional otherwise."))
((:path . "arg-opt-all-comps-drop-wth-no-marker") (:content . "All complements can be dropped. No marker."))
((:path . "all-subj-drop-wth-opt-marker") (:content . "Subject dropping for all verbs with a marker left optionally for both dropped and overt subjects"))
((:path . "all-subj-drop-wth-req-marker") (:content . "All subject droppiuired marker for both dropped and overt subjects.  No object dropping."))
((:path . "lex-subj-drop") (:content . "Lexical subject dropping with no marker.  No object dropping"))
((:path . "subj-drop") (:content . "All subjects caobjects can be dropped.  No markers for subject dropping."))
((:path . "auxfeatures-onlyformmarked") (:content . "auxfeatures-onlyformmarked: testing features on the auxiliaryFORM marked on the complement verb"))
((:path . "compfeatures-onlyformmarked") (:content . "compfeatures-onlyformmarked: testing features on auxiliary complement but only FORM is marked on the verb"))
((:path . "compfeatures") (:content . "compfeatures: testing features on the auxiliary complement"))
((:path . "auxfeatures") (:content . "auxfeatures: testing features on auxiliary verb"))
((:path . "case-optadp") (:content . "case-optadp: case with optional adpositional marking"))
((:path . "case-mixed-optadp") (:content . "case-mixed-optadp: case with mixed optional adpositional and morphological marking"))
((:path . "case-mixed") (:content . "case-mixed: case, mixed adpositional and morphological marking"))
((:path . "Finnish") (:content . "Finnish: Finnish test for morphotactics"))
((:path . "Slave") (:content . "Slave: Slave test for morphotactics"))
((:path . "Zulu") (:content . "Zulu: Zulu test for morphotactics"))
((:path . "pre-vp-adv-neg") (:content . "pre-vp-adv-neg: Negation as independent pre-VP modifier"))
((:path . "mini-infl-neg") (:content . "mini-infl-neg: Negation as inflection, simple case"))
((:path . "test-stative") (:content . "test-stative: testing assignment of prog-asp to non-stative-ing comp, ignoring tense/person/number/spelling, only transitive"))
((:path . "view-situ-aspect-infl") (:content . "view-situ-aspect-infl: situation and viewpoint aspect as inflection"))
((:path . "view-inf-situ-inher") (:content . "view-inf-situ-inher: inflected viewpoint and inherent situation aspect"))
((:path . "free-one-aux-max-v") (:content . "free-one-aux-max-v: tests free word order with no verbal clusters, thus maximum one aux"))
((:path . "vso-aux-before-v-no-cluster") (:content . "vso-aux-before-v-no-cluster: test vso word order where aux precedes its v-complement and does not form a verbal cluster"))
((:path . "vso-aux-before-v-cluster") (:content . "vso-aux-before-v-cluster: testing vso word order where the aux precedes its v-comp forming a verbal cluster"))
((:path . "vso-aux-after-v") (:content . "vso-aux-after-v: testing vso word order where the auxiliary follows its v-complement"))
((:path . "v-initial-aux-before-v") (:content . "v-initial-aux-before-v: testing v-initial word order with aux preceding its v-complement"))
((:path . "v-initial-aux-after-v") (:content . "v-initial-aux-after-v: testing v-initial word order when the auxiliary follows its v-complement"))
((:path . "v-initial-aux-before-vp") (:content . "v-initial-aux-before-vp: testing v-initial word order where the auxiliary precedes its vp complement"))
((:path . "v-initial-aux-after-vp") (:content . "v-initial-aux-after-vp: testing v-initial word order with auxiliaries following their vp-complement"))
((:path . "svo-aux-before-v") (:content . "svo-aux-before-v: testing svo word order with auxiliary preceding v-comp"))
((:path . "svo-aux-after-v") (:content . "svo-aux-after-v: testing svo word order with aux following its v-complement"))
((:path . "sov-aux-before-v") (:content . "sov-aux-before-v: testing sov word order with auxiliaries preceding their v-comp"))
((:path . "sov-aux-after-v") (:content . "sov-aux-after-v: testing sov word order where auxiliaries precede v-comp"))
((:path . "free-aux-before-v-cluster") (:content . "free-aux-before-v-cluster: testing free word order with preceding auxiliaries that take a v-comp and form a v-cluster"))
((:path . "free-aux-after-v-cluster") (:content . "free-aux-after-v-cluster: testing free word order where the aux follows its vcomp and forms verbal clusters"))
((:path . "vso-aux-before-vp") (:content . "vso-aux-before-vp: testing vso word order where auxiliary precedes main-verb and takes vso complement style Irish and Welsh"))
((:path . "multi-featured-aux") (:content . "multi-featured-aux: very! short test of features on the auxiliary itself"))
((:path . "free-aux-before-vp") (:content . "free-aux-before-vp: testing free word order with auxiliary that needs to come before its verbal complements"))
((:path . "free-aux-after-vp") (:content . "free-aux-after-vp: testing word order with auxiliaries following their vp-compl, else free word order"))
((:path . "vos-aux-after-vp") (:content . "vos-aux-after-vp: testing word order for vos languages in which the auxiliary follows its vp complement"))
((:path . "vos-aux-before-vp") (:content . "vos-aux-before-vp: testing word order for vos languages with auxiliaries preceding their vp complement"))
((:path . "ovs-aux-before-vp") (:content . "ovs-aux-before-vp: tests word order ovs with auxiliaries that precede their vp complement"))
((:path . "ovs-aux-after-vp") (:content . "ovs-aux-after-vp: testing ovs word order with auxiliaries that follow their vp complement"))
((:path . "aux-assigns-subj-case-vp") (:content . "aux-assigns-subj-case-vp: grammar tests case restrictions imposed by auxiliary: here the auxiliary aentence"))
((:path . "vos-vp-aux-case-rais") (:content . "vos-vp-aux-case-rais: testing case constraints imposed by the auxiliary: here it raises the case value from its vcomp's subject"))
((:path . "v2-aux-eitherside-vp") (:content . "v2-aux-eitherside-vp: v2nd word order with one auxiliary that takes a vp complement on either side"))
((:path . "v2-aux-eitherside-v") (:content . "v2-aux-eitherside-v: v2nd word order with one auxiliary that takes a v (not vp) complement which can appear freely on either side ofthe aux"))
((:path . "multi-select-case") (:content . "multi-select-case: multi-select of feature values, namely case"))
((:path . "nf-twoforms-withtwoaux-vp-1008") (:content . "nf-twoforms-withtwoaux-vp-1008: testing-- two nonfinite forms"))
((:path . "nf-form-withaux-vp-1008") (:content . "nf-form-withaux-vp-1008: testing nonfinite form constraint for aux complement"))
((:path . "fin-forms-noaux-1008") (:content . "fin-forms-noaux-1008: testing finite/nonfinite distinction when there are no auxiliaries"))
((:path . "auxcomp-markfeature-vp-1015") (:content . "auxcomp-markfeature-vp-1015: testing KEYS.KEY mhat is being used to distinguish etre and avoir type auxiliary verb classes"))
((:path . "auxcomp-feature-engstative-vp-1013") (:content . "auxcomp-feature-engstative-vp-1013: testing verb class feature stative and aux constrained to nonstative"))
((:path . "noaux-toblig-aopt-onv") (:content . "noaux-toblig-aopt-onv: obligatory tense, optional aspect on v, no aux level 3 test"))
((:path . "auxten-vpcompnfasp-tafeat") (:content . "auxten-vpcompnfasp-tafeat: tensed auxilialevel 3 test"))
((:path . "nopaux-noinfl-vpcomp-f-formfeat") (:content . "nopaux-noinfl-vpcomp-f-formfeat: single uninflected aux with finite vp complement, level 2 test (inflection but no t&a features)"))
((:path . "aux-f-vpcomp-nfconst-formfeat") (:content . "aux-f-vpcomp-nfconst-formfeat: finite auxes with nf vp compleof the nf comp is constrained - level 2 test (inflection, no t&a features)"))
((:path . "aux-v-f-noinfl") (:content . "aux-v-f-noinfl: two aux, finite v vomp, no inflection, level 1 test"))
((:path . "aux-vp-f-noinfl") (:content . "aux-vp-f-noinfl: two aux, finite vp comp, no inflection, level 1 test"))
((:path . "aux-s-f-noinfl") (:content . "aux-s-f-noinfl: two aux, finite sentential compelement, no inflection, level1 test"))
((:path . "testingcompforms") (:content . "testingcompforms: small ts - known problems"))
((:path . "dir-inv-fore") (:content . "dir-inv-fore: Direct-inverse, pseudo-Fore"))
((:path . "dir-inv-algonquian") (:content . "dir-inv-algonquian: Direct-inverse, pseudo-Algonquian"))
((:path . "case-tripartite") (:content . "case-tripartite: Case, tripartite"))
((:path . "case-split-v") (:content . "case-split-v: Case, split-V"))
((:path . "case-split-s") (:content . "case-split-s: Case, split-S"))
((:path . "case-split-n") (:content . "case-split-n: Case, split-N"))
((:path . "case-none") (:content . "case-none: Case, none"))
((:path . "case-nom-acc-adp") (:content . "case-nom-acc-adp: Case, nominative-accusative w/ adpositions"))
((:path . "case-nom-acc") (:content . "case-nom-acc: Case, nominative-accusative"))
((:path . "case-focus") (:content . "case-focus: Case, focus"))
((:path . "case-fluid-s") (:content . "case-fluid-s: Case, fluid-S"))
((:path . "case-erg-abs") (:content . "case-erg-abs: Case, ergative-absolutive"))
 )
